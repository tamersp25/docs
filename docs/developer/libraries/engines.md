# Library-Enabled engines

An engine will typically act on an individual library per execution. When run in a special "training" mode, the engine should consume applicable identifier assets from the provided library and, depending on the type of engine, generate a trained model. This model is the engine's internal representation of the library and an engine state that can be referenced by future invocations. This process is demonstrated in the diagram below:

![](https://gcc-elb-public-prod.gliffy.net/embed/image/3a64764f-4d70-4f63-8561-55b8c0409634.png?utm_medium=live&utm_source=custom)


## Engine Configuration

An engine must configured to be library-enabled. To do so, a field called `libraryRequired` must be set to true on the engine definition. When you create your engine using the VDA "Create engine" wizard, check the "Library Required" option. You can also set this option after engine creation
from the Configuration tab on the engine detail page.

Additionally, depending on the engine category, the engine is configured to consume one or more specific identifier types, specified by the `libraryIdentifierTypes` field. This value is defined on the engine category and cannot be changed. The relationship between engine categories and identifier types is managed by Veritone and cannot be changed.

To see the mappings between engine categories and identifier types,
use the following query:
```graphql
query {
  engineCategories {
    records {
      id
      name
      libraryEntityIdentifierTypes {
        records {
          id
          label
          labelPlural
        }
      }
    }
  }
}
```

Engine categories that support libraries will have lists of
compatible identifier types. For example:
```json
{
          "id": "6faad6b7-0837-45f9-b161-2f6bf31b7a07",
          "name": "Facial Detection",
          "libraryEntityIdentifierTypes": {
            "records": [
              {
                "id": "face",
                "label": "Face",
                "labelPlural": "faces"
              }
            ]
          }
        },
        {
          "id": "088a31be-9bd6-4628-a6f0-e4004e362ea0",
          "name": "Object Detection",
          "libraryEntityIdentifierTypes": {
            "records": [
              {
                "id": "image",
                "label": "image",
                "labelPlural": "images"
              }
            ]
          }
        }, ...
```

Therefore, when selecting an engine category, make sure to
choose one that has the correct set of identifier types for your engine.
The linkage is important for training -- when a library is created or
modified, the system will automatically attempt to train a new model
for all compatible engines.

## Engine modes
When enabled for Libraries, the engine must support two specific modes, specified as "mode" in the task payload provided to the engine:

* `library-train`: run the engine in training mode.
* `library-run`: run the engine against a provided TDO, or recording, ID and a previously trained library.

Your engine will run in training mode whenever a compatible
library is published after creation or update, such as when
new entities are added.

It will run in run mode whenever anyone _uses_ the engine
for its primary purpose, such as facial recognition.

Thus, for a typical engine, `library-run` mode will be the
most common case by far.

## Test libraries

The simplest way to build a library to be consumed by your engine is via the [Library app](https://library.veritone.com/libraries). Alternatively, you may use the Libraries GraphQL API to generate a library.

A library must be "published" before it is available as a training set for an engine. For deployed engines, this process is performed automatically and a training task is created for all applicable engines. The payload for each of these tasks is expected to contain two key values:

* `libraryId`: the unique ID (UUID) of the library to train the engine with
* `libraryEngineModelId`: a UUID referencing the model generated by this task.

The `libraryEngineModelId` is unique to not only this engine, but each training task, i.e. each time a library is modified and "published", and new library engine model is generated.

While your engine is under development and may not be deployed and in an active state, the library engine model will need to be generated manually. To do so, simple execute the following GraphQL query:

```graphql
mutation {
  createLibraryEngineModel(input: {
    engineId: 'your-engine-id'
    libraryId: 'your-library-id'
  }) {
    id
  }
}
```
This query will return the libraryEngineModelId that can be used in your sample payload. It can be re-used as necessary.

Continue on to [training engines](/developer/libraries/training).
