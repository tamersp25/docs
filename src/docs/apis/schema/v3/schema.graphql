# Used to authorize access to a given query, mutation, or field
# based on permissions set in the user token.
# for example, to restrict a field foo to superadmins, add
#   foo: Foo @scopes(scopes: ["superadmin"])
# Permission strings must EXACTLY match the permission objects defined
# in functional-permissions-lib. If the user does not have all required
# permissions, the field will contain null and the errors list will
# have an "access denied" error message.
directive @scopes(
  # List of one or more scopes required for the field
  scopes: [String!]!

  # Whether or not to require _all_ scopes listed or only any one of them.
  # Default is All.
  require: ScopeRequirement = All
) on QUERY | MUTATION | FIELD

# Used to require authentication and to enforce organization-level
# authorization. This directive, with default parameters, is applied by
# default to all queries and mutations. Parameter values can be overridden
# by setting it explicitly on a field.
# The @noAuth directive can be explicitly used on fields that do not
# require authentication.
# Examples:
#  Allow org-less tokens to access objects of type TemporalDataObject
#  based on the id parameter.
#   @auth(allowOrgless: true, objectAuthType: TemporalDataObject)
# Allow org-less tokens to use the field with no object restrictions.
# The @scopes directive might still apply.
#   @auth(allowOrgless: true, skipObjectAuthorization: true)
# Allow org-less tokens to use the field if the ID referenced in parentId
# is in the allowed set of TemporalDataObjects. Useful for something like
# createAsset.
#   @auth(allowOrgless: true, objectAuthType: TemporalDataObject,
#         objectAuthIdParam: parentId)
directive @auth(
  # Whether or not to allow access for org-less (engine) tokens
  allowOrgless: Boolean = true

  # Whether or not to skip object-level authorization for org-less tokens.
  # Use with caution.
  skipObjectAuthorization: Boolean = false

  # The type of object that object-level access controls should apply to.
  # Must be set if allowOrgless is true and skipObjectAuthorization is false.
  objectAuthType: AuthObjectType

  # The name of the field parameter containing id(s) to query for.
  # Object-level authorization will authorize this value against the list of
  # allowed object resources for the token.
  objectAuthIdParam: String = "id"
) on QUERY | MUTATION | FIELD

# Used to explicitly declare that a given field does not require authentication.
# Use with caution.
directive @noAuth on QUERY | MUTATION | FIELD

directive @tokenType(type: TokenType!) on QUERY | MUTATION | FIELD

directive @log on QUERY | MUTATION | FIELD

directive @noLog on QUERY | MUTATION | FIELD

directive @featureFlag(
  # default value for the feature flag to use if it is not provided
  # in configuration or on the org
  defaultValue: Boolean = false

  # Optional name for the feature flag. The default will be the
  # mutation, query, or field name to which the directive is attached.
  name: String
) on QUERY | MUTATION | FIELD | ARGUMENT_DEFINITION

directive @audit(objectType: String, action: AuditAction, skip: Boolean) on MUTATION

directive @limit(cost: Int) on QUERY | MUTATION | FIELD

input AddLibraryDataset {
  # Id of the selected library
  libraryId: ID!

  # List of tdo ids to add to the selected library
  tdoIds: [ID]!
}

input AddMediaSegment {
  # ID of the TemporalDataObject container for the segment
  containerId: ID!

  # Details for the segment, such as start and stop offset
  details: JSON!

  # The url to the segment content.
  url: String!
}

input AddTask {
  id: ID!
  jobId: ID!
  engineId: ID!
  buildId: ID!
  status: TaskStatus!
  createdDateTime: DateTime!
  payload: JSON
  parentTaskId: ID
}

input AddTasksToJobs {
  tasks: [AddTask!]
}

type AddTasksToJobsError {
  id: ID
  message: String
}

type AddTasksToJobsResponse {
  createdTasks: [Task]
  errors: [AddTasksToJobsError]
}

# An application is a set of Veritone functionality that customers can sign up for.
type Application {
  id: ID!
  key: String!
  name: String!
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  deploymentModel: DeploymentModel
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  # OAuth2 client secret. This field is server-generated and is only
  # returned on application creation.
  clientSecret(password: String): String

  # OAuth2 redirect URLs
  oauth2RedirectUrls: [String]
  organizationId: ID!
  status: ApplicationStatus
  permissionsRequired: [String]
  contextMenuExtensions: ContextMenuExtensionList
  validStateActions: [ApplicationStateAction]
  components: ApplicationComponent
  dailyTaskMetrics: DailyTaskMetricsList
}

type ApplicationComponent {
  engines: EngineList
  dataRegistries: DataRegistryList
  contextMenuExtensions: [ContextMenuExtension]
}

enum ApplicationComponentType {
  engines
  dataRegistries
}

type ApplicationList implements Page {
  records: [Application]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

# TODO
type ApplicationPlatform {
  # The application platform ID
  id: ID

  # Platform type, such as TODO
  platformType: String

  # The application platform URL.
  platformUrl: String
}

enum ApplicationStateAction {
  approve
  edit
  delete
  deploy
  disable
  enable
  reject
  submit
  undelete
}

# Set of possible states for a custom application.
# The application state determines whether or not it is available in production
# and the actions that can be taken on it.
enum ApplicationStatus {
  # The application is active (production state)
  active

  # The application is in draft state during test and development
  draft

  # The application has been deleted and is no longer available for any purpose
  deleted

  # The application is awaiting approval.
  pending

  # The application has been rejected and must be modified and re-submitted.
  rejected

  # The application has been approved and can now be deployed.
  approved

  # The application has been disabled, but not deleted.
  disabled
}

input ApplicationWorkflow {
  id: ID!
  action: ApplicationWorkflowAction!
}

enum ApplicationWorkflowAction {
  submit
  approve
  reject
  deploy
  enable
  disable
  undelete
}

# An asset represents a single unit of data, such as a file or URL,
# and basic metadata about that data. An asset must be contained within
# a TemporalDataObject.
type Asset {
  # The asset ID
  id: ID!

  # Asset name, such as a file name.
  name: String

  # Asset content type. Must be a valid MIME type string.
  contentType: String

  # An optional description of the asset
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  # Freeform metadata in JSON format.
  jsondata: JSON

  # The ID of the TemporalDataObject that contains this asset
  containerId: ID!

  # The TemporalDataObject that contains this asset
  container: TemporalDataObject

  # The asset's URI. If a file is provided on asset creation, this URI
  # point to the object in Veritone's object storage.
  uri: String

  # A signed version of the asset's URI
  signedUri: String

  # deprecated - use assetType
  type: String! @deprecated(reason: "Duplicate, redundant field")

  # The asset type, such as `media`, `transcript`, or `text`.
  # The asset type determines which engines are able to operate on it.
  # For example, a transcription engine requires a `media` asset.
  # Engines that record their results in an asset typically set the type
  # accordingly, such as `vtn-standard`.
  # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
  assetType: String

  # Freeform application-defined metadata. This field may contain information
  # specific to the object type, such as image or video metadata.
  details(
    # optionally, specify a path to retrieve only a specific property
    # within the details JSON
    path: String
  ): JSON

  # Metadata as raw JSON string
  jsonstring(indent: Int = 2): String

  # A structured containing metadata about a file. This will be set if the
  # asset was created by uploading a file.
  fileData: AssetFileData

  # A structure containing metadata about the source engine and task. This will
  # be set if the asset was created by an engine.
  sourceData: AssetSourceData

  # Asset transform. The transformation function to be used with the asset.
  # It can be XML to JSON
  transform(transformFunction: TransformFunction!): String

  # A Boolean indicating whether or not this asset was created by editing
  # another asset.
  isUserEdited: Boolean
}

enum AssetCreationMode {
  create
  append
  replace
}

# A structured containing metadata about an asset file.
type AssetFileData {
  # The MD5 checksum of the file
  md5sum: String

  # The file size in bytes
  size: Int

  # Original file URI, if provided on asset creation
  originalFileUri: String

  # Media duration in milliseconds
  mediaDurationMs: Int
}

type AssetList implements Page {
  records: [Asset]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum AssetOrderBy {
  createdDateTime
  assetType
  contentType
}

# A structure containing metadata about the source engine and task for an asset.
type AssetSourceData {
  # The name of the asset source engine or engine category
  name: String

  # ID of the specific task that created the asset
  taskId: ID

  # The specific task that created the asset
  task: Task

  # The ID of the engine that created the asset
  engineId: ID

  # The engine that created the asset
  engine: Engine

  # The ID of the source from which this asset was generated or stamped.
  sourceId: ID

  # ID of the schema describing this asset, if there is one.
  # Typically applies only to assets of type "content-template".
  schemaId: ID

  # The schema definition, if there is one
  schema: Schema
}

enum AuditAction {
  Create
  Update
  Delete
}

type AuditEvent {
  id: String!
  organizationId: ID!
  userId: ID

  # The application that created the audit log
  application: String
  payload: JSON!
}

type AuditEventList implements Page {
  records: [AuditEvent!]
  offset: Int!
  limit: Int!
  count: Int
}

type AuditLogEntry {
  # ID of the organization that generated the audit entry.
  organizationId: ID

  # The type of the object involved in the audit action, such as `Watchlist`
  # or `TemporalDataObject`.
  objectType: String

  # The ID of the object involved in the audit action. The format of this ID
  # varies by object type.
  objectId: ID

  # The unique ID of the audit log entry.
  id: ID!

  # The event type, such as `Create`, `Update`, or `Delete`.
  eventType: String

  # User name or ID that generated the audit entry. This might be an API key.
  userName: String

  # Indicates whether or not the attempted action was successful.
  success: Boolean

  # IP address of the client that generated the audit action.
  clientIpAddress: String

  # HTTP user agent of the client that generated the audit action.
  clientUserAgent: String
  description: String

  # Date/time at which the audit log entry was created.
  createdDateTime: DateTime!
}

type AuditLogEntryList implements Page {
  records: [AuditLogEntry!]!

  # Count of records in this page. Will be less than or equal to `limit`.
  count: Int

  # Offset used in the query that generated this page.
  offset: Int!

  # Limit used in the query that generated this page.
  limit: Int!

  # `toDateTime` value of the query that generated this page.
  # Useful when a default was applied.
  toDateTime: DateTime

  # `fromDateTime` value of the query that generated this page.
  # Useful when a default was applied.
  fromDateTime: DateTime
}

# Specifies an "order by" entry in the `auditLog` query
input AuditLogOrderBy {
  field: AuditLogOrderByField
  direction: OrderDirection
}

# Fields that can be set in an `auditLog` `orderBy` parameter
enum AuditLogOrderByField {
  id
  objectId
  objectType
  createdDateTime
  eventType
  userName
  clientIpAddress
  clientUserAgent
  success
}

enum AuthObjectType {
  TemporalDataObject
  Job
  Task
  Folder
}

type AutocompleteFieldConfig {
  autocompleteField: String
  indexField: String
}

type BenchmarkJob {
  id: ID
  jobIds: [ID]
  baselineEngineId: ID!
  engineIds: [ID]
  createdDateTime: DateTime!
  createdBy: String
}

type BenchmarkJobs implements Page {
  # Count of records in this page. Will be less than or equal to `limit`.
  count: Int

  # Offset used in the query that generated this page.
  offset: Int!

  # Limit used in the query that generated this page.
  limit: Int!

  # List of shared collection history records
  records: [BenchmarkJob]
}

# Type representing a boolean property
type BooleanProperty implements Property {
  name: String!
  value: Boolean
}

type Build {
  id: ID!
  name: String
  description: String

  # Date and date build was created
  createdDateTime: DateTime

  # Date and time build was last modified
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  # The ID of the engine this build is for
  engineId: ID!

  # The engine this build is for
  engine: Engine
  price: Int
  validateUri: String
  executeUri: String

  # Engine build status:
  status: BuildStatus

  # URL to the Docker image for this engine build, if applicable
  dockerImage: String
  runtime: JSON
  version: String
  report: JSON

  # The entire manifest, supplied by the engine developer, that describes
  # the engine's capabilities and requirements and is used by the platform
  # system to build and execute the engine.
  manifest: JSON
  preferredInputFormat: String
  supportedInputFormats: [String!]
  outputFormats: [String!]

  # List of IDs of source types that the engine supports.
  # Applies only to adapter engines that ingest data from a source.
  # Will be a list of IDs of SourceType objects.
  supportedSourceTypes: [String!]

  # Used to give a default action choice
  primaryAction: BuildUpdateAction

  # Used to give secondary action choices
  secondaryActions: [BuildUpdateAction]

  # Contains all valid action choices
  validStateActions: [BuildUpdateAction]
}

type BuildList implements Page {
  records: [Build]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

# Valid strings for the `Build.status` field.
enum BuildStatus {
  # The build has been approved and is ready for deployment
  approved

  # The build is available for deployment
  available

  # The build has been soft-deleted.
  deleted

  # The build is being deployed.
  deploying

  # The build has been deployed. There can be only one deployed build.
  deployed

  # The build files are being fetched from their source.
  fetching

  # The build failed validation checks. See build report for details.
  invalid

  # The build is deployed but has been paused. Engine processing will not
  # proceed until the build is un-paused.
  paused

  # The build has been created but is still pending approval and other
  # workflow steps.
  pending

  # The build has been successfully uploaded to the build repository.
  uploaded

  # Deployment has failed
  deployFailed

  # Approval was requested, but denied
  disapproved
}

enum BuildUpdateAction {
  deploy
  pause
  unpause
  approve
  disapprove
  invalidate
  submit
  upload
  delete
}

input BulkDeleteContextMenuExtensions {
  # List of IDs of context menu extensions to delete
  ids: [ID!]
}

input BulkUpdateWatchlist {
  # New stop date for watchlist. Currently, this is the only
  # field that can be updated.
  stopDate: DateTime
}

input BulkUpdateWatchlistFilter {
  # List of IDs of watchlists to update
  ids: [ID!]
}

type Bundle {
  id: ID!
  organizationId: ID
  clusterId: ID
  nodeId: ID
  name: String
  externalCredentialId: ID
  testRun: Boolean
  selectDetail: BundleSelectDetail
  selectCategory: String
  bundleResults: BundleResults
  bundleStarted: DateTime
  previousBundleStarted: DateTime
  bundleCompleted: DateTime
  deletedDate: DateTime
  createdDate: DateTime
  updatedDate: DateTime
  scheduleDefinition: BundleScheduleDefinition
  nextScheduledTime: DateTime
}

input bundleError {
  error: String!
}

type BundleError {
  error: String!
}

input bundleResults {
  found: Int!
  completed: Int!
  errors: bundleError!
}

type BundleResults {
  found: Int!
  completed: Int!
  errors: BundleError!
}

type BundleScheduleDefinition {
  recurringStartTime: DateTime
  recurringEndTime: DateTime
  repeatDaysTimeInMinutes: Int
  repeatDaysOfWeek: [Int]
  repeatDaysOfMonth: [Int]
  repeatMinutes: Int
}

type BundleSelectDetail {
  category: String!

  # Array of file types to include.
  select: [String!]

  # Array of paths to search from.
  paths: [String!]

  # Array of files to search from.
  files: [String]

  # Array of tasks to run for each job.
  tasks: [BundleSelectDetailTask]

  # Include items after this time.
  afterTime: DateTime

  # Include items before this time.
  beforeTime: DateTime
  recursiveDescent: Boolean!
  service: BundleService
}

type BundleSelectDetailTask {
  # Id of engine.
  engineId: ID!
}

type BundleService {
  serviceType: String
  region: String
  bucketName: String
}

input BundleStatus {
  bundleStarted: DateTime
  bundleCompleted: DateTime
  bundleResults: bundleResults!
  markAsCompleted: Boolean
}

type Campaign {
  id: ID!
  name: String!
  startDate: DateTime
  stopDate: DateTime
  budget: Int
  organizationId: ID!
  advertiserId: ID
  brandId: ID
  notes: String
}

input ChangePassword {
  # The current user's old password. Must be provided even if the
  # user is otherwise authenticated as an additional security check.
  oldPassword: String!

  # The new password. May be subject to validation rules depending
  # on the organization or environment system policy.
  newPassword: String!
}

# Object that represents the mapping of clone assets to its parent's assets.
type CloneAssetIdMap {
  # The original asset ID (within the cloned asset container).
  oldAssetId: ID!

  # The new asset ID (within the clone asset container).
  newAssetId: ID!
}

# Metadata that represents a clone of a recording.
type CloneData implements Metadata {
  # Timestamp when the recording was cloned
  date: String

  # The ID of the asset container this was cloned from
  originalId: String!

  # Clone blobs flag
  cloneBlobs: Boolean

  # Map of asset IDs from the clone to the parent.
  assetIdMap(
    # Provide an ID to retrieve mappings for specific old asset.
    oldAssetId: ID

    # Provide an ID to retrieve mappings for a specific new asset.
    newAssetId: ID
  ): [CloneAssetIdMap]
  name: String!
}

type CloneRequest {
  id: ID!
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  numberOfRecordings: Int
  numberOfCompletedRecordings: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: String
  percentage: Int
}

type CloneRequestList implements Page {
  records: [CloneRequest]
  count: Int
  offset: Int!
  limit: Int!
}

input CloneScheduledJob {
  id: ID!

  # Organization ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  organizationId: ID
}

type Cluster {
  id: ID!
  nodes: ClusterNodeList
  name: String
  isPublic: Boolean
  type: ClusterType
  organizationId: ID
  allowedEngines: [ID!]
  containerTag: String
  paused: Boolean
  memorySizeBytes: Float
  storageSizeBytes: Float
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  deletedDateTime: DateTime
  cachedDateTime: DateTime
  default: Boolean
  bypassAllowedEngines: Boolean
  collaborators: ClusterCollaboratorList

  # Retrieve jobs
  jobs(
    # Provide an ID to retrieve a single specific job.
    id: ID

    # Provide a list of status strings to filter by status
    status: [JobStatusFilter!]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify the maximum number of results to included in this response, or page size.
    limit: Int = 30

    # Provide an application ID to filter jobs for a given application.
    # Defaults to the user's own application.
    applicationId: ID

    # Provide a target ID to get the set of jobs running against a particular TDO.
    targetId: ID

    # Provide a list of scheduled job IDs to get jobs associated with the scheduled jobs
    scheduledJobIds: [ID!]

    # Provide sort information. The default is to sort by
    # createdDateTime descending.
    orderBy: [JobSortField!]

    # Filter by date/time field. If a filter is not provided, a default of
    # `createdDateTime` between now and 1 day ago will be applied.
    dateTimeFilter: [JobDateTimeFilter!]

    # Provide list of application IDs to filter jobs.
    # Defaults to the user's own application.
    applicationIds: [ID]
  ): JobList!
  tasks(
    # Specify a list of job status strings to filter by status
    status: [TaskStatus!]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Maximum number of results to retrieve in this query
    limit: Int = 30

    # Specify an ID to retrieve a single specific task
    id: ID

    # If a filter is not provided, a default of `createdDateTime` between
    # now and 1 day ago will be applied.
    dateTimeFilter: [TaskDateTimeFilter!]
  ): TaskList!

  # Retrieve current subscriptions for events on this cluster.
  subscriptions: ClusterSubscriptionList!

  # Retrieve tags for this cluster
  tags: [String!]

  # Retrieve the cluster's current status
  status: ClusterStatus!

  # Cluster configuration overrides
  clusterConfig: JSON

  # State information about the cluster, conforming to a stable schema.
  state: JSON

  # Date and time at which the state was last updated the system.
  stateLastUpdatedDateTime: DateTime

  # media storage option
  mediaStorage: MediaStorageOption!

  # media storage path -- applies to edge only
  mediaStoragePath: String

  # ID of the management node. Applies to portable/edge clusters only.
  managementNodeID: ID

  # Optionally, specify a time at which the edge cluster should
  # be restarted daily. Applies only to edge clusters.
  restartTimeUTC: Time

  # Retrieve the cluster's service token
  serviceToken: String

  # Cluster deployment process status
  targetStatus: ClusterStatus
}

# A source ACL grants a single organization limited rights to a private clusters
type ClusterCollaborator {
  # The permission granted.
  permission: ClusterPermission!

  # Organization ID the cluster was shared with
  organizationId: ID!

  # The organization the cluster was shared with
  organization: Organization
}

type ClusterCollaboratorList implements Page {
  records: [ClusterCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum ClusterDateTimeField {
  createdDateTime
  modifiedDateTime
  stateLastUpdatedDateTime
}

input ClusterDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: ClusterDateTimeField!
}

type ClusterList implements Page {
  records: [Cluster!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ClusterNode {
  id: ID!
  clusterId: ID
  cluster: Cluster
  name: String
  metrics: JSON

  # Cluster configuration overrides
  nodeConfig: JSON
  paused: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type ClusterNodeList implements Page {
  records: [ClusterNode]
  count: Int!
  offset: Int!
  limit: Int!
}

input ClusterNodeUpdate {
  nodeId: ID!
  metrics: JSON
}

input ClusterOrderBy {
  field: ClusterOrderByField!
  direction: OrderDirection = desc
}

enum ClusterOrderByField {
  name
  createdDateTime
  modifiedDateTime
  stateLastUpdatedDateTime
}

enum ClusterPermission {
  owner
  viewer
}

enum ClusterSize {
  small
  medium
  large
}

enum ClusterStatus {
  pending
  active
  deploying
  online
  paused
  terminated
  failure
}

type ClusterSubscription {
  userId: ID!
  emailAddress: String!
  id: ID!
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  isActive: Boolean!
}

type ClusterSubscriptionList implements Page {
  records: [ClusterSubscription!]!
  count: Int!
  offset: Int!
  limit: Int!
}

enum ClusterType {
  # Amazon Machine Image
  ami

  # Real-Time
  RT

  # On Premise
  OnPrem
}

type CognitiveSearch {
  id: ID!

  # A recursive tree structure defining the search criteria
  profile: JSON

  # ID of the mention status to set on each mention generated as a result
  # of a match against this search
  mentionStatusId: ID

  # The mention status to set on each mention generated as a result
  # of a match against this search
  mentionStatus: MentionStatus

  # The raw query. Read-only and server-generated based on the search profile.
  query: JSON
}

type CognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSON!
}

type CognitiveSearchProfile {
  and: [CognitiveSearchProfile!]
  or: [CognitiveSearchProfile!]
  condition: CognitiveSearchCondition
  jsondata: JSON
}

type Collection {
  id: ID!
  name: String!

  # A url to get the collection image
  imageUrl: String

  # A signed url to get the collection image. It will only be signed if it is an s3 url.
  signedImageUrl: String
  ownerId: ID
  description: String
  organization: Organization
  organizationId: ID!
  orgSharing: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  programCount: Int
  itemCount: Int
  typeId: ID
  isActive: Boolean
  widgets(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Maximum number of results to retrieve in this query; page size
    limit: Int = 30
    id: ID
  ): WidgetList

  # Get a list of mentions filed in the collection
  mentions(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Maximum number of results to retrieve in this query; page size
    limit: Int = 30
    id: ID
  ): CollectionMentionList
}

type CollectionList implements Page {
  records: [Collection]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type CollectionMention {
  # id of the collection
  folderId: ID!

  # id of the mention
  mentionId: ID!
  organizationId: ID!
  mention: Mention!
  collection: Collection!
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

input CollectionMentionInput {
  # id of the collection
  folderId: ID!

  # id of the mention
  mentionId: ID!
}

type CollectionMentionList implements Page {
  records: [CollectionMention!]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int!
}

input CollectionMentionOrderBy {
  field: CollectionMentionOrderField!
  direction: OrderDirection = desc
}

enum CollectionMentionOrderField {
  mentionDate
}

type CompoundProperty implements Property {
  name: String!
  value: KVP
}

type ContextMenuExtension {
  # context menu extension id
  id: ID
  label: String
  url: String
  type: String
}

type ContextMenuExtensionList {
  mentions: [ContextMenuExtension]
  tdos: [ContextMenuExtension]
  watchlists: [ContextMenuExtension]
  collections: [ContextMenuExtension]
}

enum ContextMenuExtensionType {
  mention
  watchlist
  collection
  tdo
}

input CreateAllPipelineJobs {
  jobPipelineId: ID!
  jobPipelineStage: Int = 1

  # Optional data about the job target,
  # a TemporalDataObject. If this field is
  # not specified then a suitable
  # object will be created automatically.
  targetInfo: CreateAllPipelineJobsTargetInfo

  # Job payload
  payload: JSON

  # Supply this value if and only if the job pipeline
  # was started as part of a scheduled job.
  scheduledJobId: ID
  organizationId: ID
  applicationId: ID
}

input CreateAllPipelineJobsTargetInfo {
  # ID of the target object for the job pipeline,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input CreateApplication {
  name: String!
  key: String!
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  oauth2RedirectUrls: [String]
  checkPermissions: Boolean!
  permissionsRequired: [String]
  deploymentModel: DeploymentModel
  contextMenuExtensions: CreateContextMenuExtensions
}

input CreateAsset {
  # ID of the parent container, a TemporalDataObject, for the new asset
  containerId: ID!

  # A valid MIME type
  contentType: String

  # An optional description for the asset
  description: String

  # A file to upload. Use multipart form POST to submit this field.
  file: UploadedFile

  # Optional expected checksum for the file
  md5sum: String

  # The asset type. Either this or assetType must be provided.
  # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
  assetType: String

  # deprecated - use assetType
  type: String

  # URI to the asset data. Optional -- if a file is provided, the URI
  # will be computed by the server.
  uri: String

  # Optionally, set attributes about the file
  fileData: SetAssetFileData

  # Optionally, set attributes about the source engine and task
  sourceData: SetAssetSourceData

  # Application- or type-specific metadata
  details: JSON

  # File or other name
  name: String

  # Deprecated. Set `fileData`, `sourceData`, or `details` instead.
  jsondata: JSON

  # if true, sets the new asset to be the primary asset of its type.
  # Only certain asset types, such as "media" and "transcript",
  # can have primary assets.
  setAsPrimary: Boolean = false

  # Set to true if this asset was created by editing another asset.
  isUserEdited: Boolean = false

  # Set to true if the container stopDateTime needs to be updated by
  # the duration of the asset
  updateContainerStopDateTime: Boolean = false

  # Set to true if the input asset uri is to be treated as a reference
  # (owned by third-party).  If set to true the source file at uri will
  # not be deleted when deleting asset.
  storeAsReference: Boolean = false
}

input CreateAssetInTDO {
  # A valid MIME type
  contentType: String

  # An optional description for the asset
  description: String

  # Asset type
  # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
  assetType: String!

  # URI to the asset data.
  uri: String!

  # Optionally, set attributes about the file
  fileData: SetAssetFileData

  # Optionally, set attributes about the source engine and task
  sourceData: SetAssetSourceData

  # Application- or type-specific metadata
  details: JSON

  # File or other name
  name: String

  # If true, sets the new asset to be the primary asset of its type.
  # Only certain asset types, such as "media" and "transcript",
  # can have primary assets.
  setAsPrimary: Boolean = false

  # Set to true if the input asset uri is to be treated as a reference
  # (owned by third-party).  If set to true the source file at uri will
  # not be deleted when deleting asset.
  storeAsReference: Boolean = false
}

input CreateBenchmark {
  tdos: [ID!]
  engineIds: [ID!]
  baselineEngineId: ID!

  # the type of engine category to benchmark
  engineCategoryId: ID!
}

input CreateBuild {
  engineId: ID!
  taskRuntime: JSON
  dockerImage: String
  manifest: JSON
}

input CreateCluster {
  name: String!
  allowedEngines: [String]!
  dockerCredentials: JSON!
  type: ClusterType
  containerTag: String
  paused: Boolean

  # Specify memory size in raw bytes or in human-readable
  # format such as 8gb, 1024mb, etc.
  memorySize: String

  # Specify storage size in raw bytes or in human-readable
  # format such as 8gb, 1024mb, etc.
  storageSize: String
  bypassAllowedEngines: Boolean

  # Permissions granted to other organizations. Only the cluster owner
  # can view or edit this field.
  collaborators: [CreateClusterCollaborator!]

  # Set subscriptions on the cluster.
  subscriptions: [CreateClusterSubscription]

  # Tags for cluster
  tags: [String]

  # Status for cluster
  status: ClusterStatus

  # Update the cluster config
  clusterConfig: JSON

  # media storage type (edge or core)
  mediaStorage: MediaStorageOption = core

  # Media storage path. Optional -- use only for edge.
  mediaStoragePath: String

  # Optionally, specify a time at which the edge cluster should
  # be restarted daily. Applies only to edge clusters.
  restartTimeUTC: Time

  # Optionally, specify an api-token for cluster
  serviceToken: String

  # ID of the organization. Only Veritone platform components can set this value.
  organizationId: ID
}

input CreateClusterCollaborator {
  # ID of the organization to share
  organizationId: ID!

  # Permission to grant cluster. Can be `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetClusterPermission!
}

input CreateClusterNode {
  name: String
  clusterId: ID
  metrics: JSON!
  containerTag: String
  offlineBrowsing: Boolean
  storagePresent: Boolean

  # Update the cluster node config
  nodeConfig: JSON
}

input CreateClusterSubscription {
  userId: ID!
  isActive: Boolean = true
}

input CreateCognitiveSearch {
  profile: JSON
  jsonstring: String
  mentionStatusId: ID!
  watchlistId: ID!
}

input CreateCognitiveSearchCondition {
  engineCategoryId: ID!
  state: JSON!
}

input CreateCognitiveSearchInWatchlist {
  profile: JSON

  # String with JSON containing the cognitive search profiles
  jsonstring: String
  mentionStatusId: ID!
}

input CreateCognitiveSearchProfile {
  and: [CreateCognitiveSearchProfile]
  or: [CreateCognitiveSearchProfile]
  condition: CreateCognitiveSearchCondition
}

input CreateCollection {
  # the name of the collection
  name: String!

  # description of the collection
  folderDescription: String

  # Collection image
  image: String
}

input CreateCollectionMentions {
  # ids of the collections
  folderIds: [ID!]!

  # ids of the mentions
  mentionIds: [ID!]!
}

input CreateContextMenuExtension {
  # id of the application to create the context menu extension for
  id: ID!
  label: String!
  url: String
  type: ContextMenuExtensionType!
}

input CreateContextMenuExtensions {
  mentions: [CreateContextMenuExtension] = []
  tdos: [CreateContextMenuExtension] = []
  watchlists: [CreateContextMenuExtension] = []
  collections: [CreateContextMenuExtension] = []
}

input CreateCreative {
  name: String!
  keywords: String
  brandId: ID
  advertiserId: ID
}

input CreateDataRegistry {
  # Optionally, provide a forced ID. It must be a valid UUID.
  id: ID

  # Provide a name for the new data registry.
  name: String!

  # Provide a description for the new data registry.
  description: String!

  # Provide source information. If in doubt, set this
  # field to the same value as name.
  source: String!

  # Defines a Veritone platform system data registry.
  # Only platform components can set this value.
  isSystem: Boolean
}

input CreateDatasetConfidence {
  # Mininum Confidence Filter. Sources with confidence lower than this will be ignore
  min: Float = 0

  # Maximum Confidence Filter. Sources with confidence higher than this will be ignore
  max: Float = 100

  # allow sources with null confidence values
  allowNull: Boolean = true
}

type CreatedMediaShare {
  id: String!
  url: String!
}

# Input fields used to create a new engine.
input CreateEngine {
  # Optional given id
  id: ID

  # Indicates whether or not the engine should be public -- visible to and
  # usable by users outside the creator's organization.
  # Typically an engine should not be made public until it has been fully
  # configured and tested in production.
  isPublic: Boolean = false

  # Human-readable name for the engine
  name: String!

  # An optional description for the engine.
  description: String

  # The engine category
  categoryId: String!

  # The engine deployment model. See the DeploymentModel enum for options.
  deploymentModel: DeploymentModel!

  # An optional price indicator for the engine.
  price: Int

  # Optionally, supply custom fields that the user can set when launching
  # the engine. See developer documentation for details.
  fields: [CreateEngineField!]

  # The path for an icon image
  iconPath: String

  # The path for a logo image
  logoPath: String

  # Whether or not the engine requires a library.
  libraryRequired: Boolean = false

  # Whether or not the engine creates a TDO
  createsTDO: Boolean = false

  # List of use cases the engine serves
  useCases: [String!]

  # List of industries where the capabilities of the engine can be applied
  industries: [String!]

  # Generic Manifest for the engine based on data supplied during onboarding
  manifest: JSON
}

input CreateEngineConfiguration {
  sourceId: ID!
  credentialIds: [ID!]
}

input CreateEngineDependency {
  # The category type this engine depends on.
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String!

  # An optional asset type that the engine will expect to have
  # been created.
  assetType: String
}

input CreateEngineField {
  # Maximum value, in float format. Applies only to fields of type Number.
  max: Float

  # Minimum value, in float format. Applies only to fields of type Number.
  min: Float

  # Numerical step by which the value should be incremented or decremented in
  # the user interface, in float format. Applies only to fields of type Number.
  step: Float

  # The field type.
  type: EngineFieldType!

  # General information about the field, such as a description.
  info: String

  # A machine-readable name, or key, for the field.
  name: String!

  # A human-readable label for the field.
  label: String!

  # A set of allowed values for the field. Applies only to fields of type
  # picklist or multi-picklist.
  options: [CreateEngineFieldPicklistOption!]

  # An optional default value for the field. Taken in string format, but
  # applies to all field types.
  defaultValue: String

  # Optional default values to apply to a picklist. This field
  # should only be set for a field of type multi-picklist.
  defaultValues: [String!]

  # specifies whether the field is optional
  required: Boolean = false
}

# Represents one allowed option in a picklist.
input CreateEngineFieldPicklistOption {
  # The human-readable label for the option, such as "English-US" for a language selector.
  key: String!

  # The machine-readable value that will be sent in the engine payload, such as
  # "en-us" for a language selector.
  value: String!
}

input CreateEntity {
  name: String!
  description: String
  libraryId: ID!
  profileImageUrl: String

  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSON

  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
  isPublished: Boolean = false
}

input CreateEntityIdentifier {
  entityId: ID!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  url: String

  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSON

  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
  contentType: String!
  file: UploadedFile
  entityType: CreateEntityType

  # If the entity identifier type is image, the new file can automatically
  # be set on the entity as its profile image. This is off by default
  # (the entity profile image is not modified) but can be controlled
  # with this parameter.
  profileUpdateMode: SetEntityProfileImage = none

  # Indicates that the URL should be stored directly as a reference and
  # not uploaded to Veritone platform storage. This option is faster by
  # bypasses content validation and can result in data integrity errors
  # if the file is deleted.
  storeReference: Boolean = false
}

input CreateEntityIdentifierType {
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
  id: ID!
}

input CreateEntityType {
  name: String!
  namePlural: String!
  schema: JSON!
}

input CreateEvent {
  # Name of the event to be created
  eventName: String!

  # The type of event
  eventType: String!

  # Identifier of the app using the event. Using "system" as application will throw error
  application: String!

  # Event visibility. Private event is only visible to the app publisher.
  public: Boolean! = false

  # General description of the event
  description: String

  # Optional schema. Accept on Protocol buffer format. If not provided,
  # Custom message schema is inferred
  schemaData: String
}

input CreateEventActionTemplate {
  # The name of template.  e.g. "Run engine X for every new mention in a watchlist".
  name: String!

  # Application this template could be applied to. If application_id is null, then this is an org-wide template.
  ownerApplicationId: ID

  # use "event" for now.  In the future, we allow additional input_type types.  For example, a schedule or a tweet.
  inputType: EventActionTemplateInputType!

  # based on the input_type, input_validation describes additional validations. 
  # For example, if input_type is "event", input_validation could be a list of
  # allowed events.
  inputValidation: JSON

  # A JSON structure that is compatible/specific to the input_type.  For example,
  # if input type is "event", then input_attributes simply contain the entire event payload.
  inputAttributes: JSON

  # Either "job", "webhook", "sms", "email".  Future action_type could be "gql" where action is purely a function call.
  actionType: EventActionTemplateActionType!

  # Allows you to specify validation for the action_type.  For example, if
  # action_type is "job", perhaps only whitelist a list of engines that could be called.
  actionValidation: JSON

  # dedicated column to specify where/what the action is taking place.  For
  # example, if action is a job, then destination is an engine_id.  For webhook, a uri.
  actionDestination: String!

  # A JSON structure that is compatible with action_type.  For example, if
  # action_type is "webhook", action_attributes contain the mustache compatible
  # template to format the content.  If action_type is "job", then
  # action_attributes need to specify a job template.
  actionAttributes: JSON
}

type CreateExecutionLocation {
  clusterId: ID!
  nodeId: ID
}

input CreateExportRequest {
  # Whether or not to include TDO media assets in the export.
  # Setting this option can greatly increase the size of the export file.
  includeMedia: Boolean = false

  # Information on the TDOs to export data from
  tdoData: [CreateExportRequestForTDO!]!

  # Information on the export output configuration
  outputConfigurations: [CreateExportRequestOutputConfig!] = []
}

input CreateExportRequestFormatConfig {
  # The file extension of the export type, such as "vlf" or "ttml".
  # Must be supported by the requested engine category.
  extension: String!

  # Optional export options specific to the target engine category.
  # Options vary depending on the extension.
  # See the full list of options available at https://docs.veritone.com/#/apis/tutorials/create-export-request/
  options: JSON
}

input CreateExportRequestForTDO {
  # ID of the TDO to export from
  # Either this option _or_ mentionId must be provided.
  # This option must be provided if includeMedia is set to true on CreateExportRequest
  tdoId: ID

  # ID of the mention to export from
  # Either this option _or_ tdoId must be provided.
  mentionId: ID

  # optional start offset in milliseconds for the export, relative to TDO startDateTime
  startOffsetMs: Int

  # optional stop offset in milliseconds for the export, relative to the TDO stopDateTime.
  stopOffsetMs: Int

  # optional start date for the exported results. Takes priority over startOffsetMs.
  startDate: DateTime

  # optional end date for the exported results. Takes priority over stopOffsetMs.
  stopDate: DateTime
}

input CreateExportRequestOutputConfig {
  # ID of an individual engine to export results for.
  # Either this option _or_ categoryId must be provided.
  engineId: ID

  # ID of an engine category to export results for.
  # Either this option _or_ engineId must be provided.
  categoryId: ID

  # Export output format configuration
  formats: [CreateExportRequestFormatConfig!]!
}

input CreateExternalCredential {
  sourceTypeId: ID
  dataId: ID
}

# Information required to create a new folder.
# After creation, a folder can be renamed with the `updateFolder` mutation,
# but no other changes are supported.
input CreateFolder {
  # The folder name
  name: String!

  # The folder description
  description: String!

  # ID of the parent folder underneath which the new folder will be placed.
  parentId: ID!

  # Root folder type to apply to the new folder
  rootFolderType: RootFolderType

  # Order index determining in what order the new folder will be displayed
  # relative to other folders at the same level.
  orderIndex: Int = 0
}

input CreateFolderContentTempate {
  # The ID of folder
  folderId: ID!

  # The ID of Structure Data Object
  sdoId: ID!

  # The ID of Data Registry
  schemaId: ID!
  data: JSON
}

input CreateJob {
  status: String
  targetId: ID
  tasks: [CreateTask!]
  retries: Int = 0

  # Optionally, specify the scheduled job ID that this job is associated
  # with. Typically it is not necessary for a client to set this; it is
  # handled internally by the API.
  scheduledJobId: ID

  # Supply a job template ID to indicate that this
  # job was created from the given job template.
  # To create a job _from_ a template, use `launchJobTemplates`.
  jobTemplateId: ID
  skipDecider: Boolean

  # Optionally, specify a cluster ID where the job should run.
  # Both the organization and the engine must have access to the cluster.
  clusterId: ID

  # Optional job config information. Typically used only by Veritone
  # platform components.
  jobConfig: JSON
  isReprocessJob: Boolean

  # Optionally, provide input needed to create a `TemporalDataObject`.
  # The new `TemporalDataObject` will be the target of this job.
  target: CreateTDOInJob

  # ID of the organization that the job should be created on behalf of.
  # Only internal platform components can set this value.
  organizationId: ID
}

input CreateJobPipeline {
  jobTemplateIds: [ID!]
  isPublic: Boolean = false
}

input CreateJobTemplate {
  # The set of task template definitions for this job template.
  taskTemplates: [CreateTaskTemplate!]

  # Optional. Specify a job pipeline ID if this job template is associated
  # with a job pipeline.
  jobPipelineId: ID

  # Optional. Should be set only if `jobPipelineId` is set.
  # Specifies the stage in the pipeline at which this job template should
  # be applied.
  jobPipelineStage: Int

  # Used only by Veritone platform components.
  skipDecider: Boolean

  # Optional job-level configuration. Typically used only by Veritone
  # platform components.
  jobConfig: JSON

  # Application ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  applicationId: ID
  clusterId: ID
}

input CreateLibrary {
  name: String!
  applicationId: ID
  organizationId: ID
  libraryTypeId: ID!
  coverImageUrl: String
  description: String
}

input CreateLibraryConfiguration {
  # ID of the selected library where this config appliess to
  libraryId: ID!

  # ID of the engine category this config applies to
  engineCategoryId: ID!

  # List of selected engines for training
  targetEngineIds: [ID]!

  # This option is used for Dataset Library Only
  # List of selected engine where tdos are extracted from for training data
  # TDOs are extracted from higher ranked engines first then fallback to the lower
  # ones if the priors don't have any matching tdo
  rankedSourceEngineIds: [ID]

  # This option is used for Dataset Library Only
  # Dataset TDOs confidence filters
  confidence: CreateDatasetConfidence
}

input CreateLibraryEngineModel {
  # ID of the engine the model is used by
  engineId: ID!

  # ID fo the library containing this engine model.
  libraryId: ID!

  # Id of the train job.
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus = pending

  # The URL to a file containing or related to the engine model.
  # Use this field if the data is stored in a separate, internet-accessible
  # location and not managed by Veritone APIs.
  # You may also use `updateLibraryEngineModel` to upload a data file.
  dataUrl: String

  # Optional free-form block containing engine-specific metadata.
  jsondata: JSON
  accuracy: Int
  configurationId: ID
}

input CreateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: CreateEntityType!
}

input CreateMediaShare {
  mediaType: String!

  # sourceId OR tdoId is required
  sourceId: ID
  tdoId: ID
  scheduledJobId: ID
  startDateTime: DateTime
  stopDateTime: DateTime
  startOffsetMs: Int
  stopOffsetMs: Int
  expireDateTime: DateTime

  # various settings for diffrent types of media. like audio only for videos
  settings: JSON
}

input CreateMention {
  mediaId: ID!
  programId: ID!
  mentionDateTime: DateTime!
  mentionHitCount: Int!
  mentionStatusId: Int
  watchlistId: ID
  cognitiveEngineResultsString: String
  cognitiveEngineResults: JSON
  snippetsString: String
  snippets: JSON
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  mentionEndDateTime: DateTime
  metadata: JSON
  queryTerm: String
}

input CreateMentionComment {
  mentionId: ID!
  commentText: String!
}

input CreateMentionExportRequest {
  # Filter information will be received to export data from
  mentionFilters: CreateMentionExportRequestFilter!

  # User local timezone
  userTimeZone: String = "America/Los_Angeles"
}

input CreateMentionExportRequestFilter {
  # List optional programIds will be filtered to export data
  programIds: [ID]

  # List optional marketIds will be filtered to export data
  marketIds: [ID]

  # List optional sourceIds will be filtered to export data
  mediaSourceIds: [ID]

  # List optional sourceTypeIds will be filtered to export data
  mediaSourceTypeIds: [ID]

  # List optional mentionStatusIds will be filtered to export data
  statusIds: [ID]

  # List optional spotTypeIds will be filtered to export data
  spotTypeList: [ID]

  # Filter mentionDate from/to
  date: CreateMentionExportRequestFilterDate

  # List optional watchlistIds will be filtered to export data
  watchlistIds: [ID]
}

input CreateMentionExportRequestFilterDate {
  from: DateTime
  to: DateTime
}

input CreateMentionRating {
  mentionId: ID!
  ratingValue: Int!
}

input CreateMentions {
  mentions: [CreateMention!]
}

input CreateNextPipelineJobs {
  jobPipelineId: ID
  parentJobId: ID
  payload: JSON
  targetInfo: CreateNextPipelineJobsTargetInfo

  # Supply this value if and only if the job pipeline
  # was started as part of a scheduled job.
  scheduledJobId: ID
  organizationId: ID
  applicationId: ID
}

input CreateNextPipelineJobsTargetInfo {
  # ID of the target object for the job pipeline,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input CreateOrganization {
  name: String!
  applications: JSON

  # Metadata in JSON format.
  metadata: JSON!
  adminSeatLimit: Int
  seatLimit: Int
  status: OrganizationStatus = active
  maxAiwareNodes: Int
  maxAiwareClusters: Int
  businessUnit: String!
  integrations: JSON
  types: [OrganizationType]
}

input CreatePasswordResetRequest {
  # Optionally specify whether we should skip sending the reset email.
  skipPasswordResetEmail: Boolean

  # The user login name. Typically email address.
  userName: String!
}

type CreatePasswordResetRequestPayload {
  message: String
}

input CreatePasswordUpdateRequest {
  # The user's ID
  id: ID!

  # Optionally specify whether we should skip sending the reset email.
  skipPasswordResetEmail: Boolean
}

input CreateProcessTemplate {
  name: String!
  taskList: JSON!
}

input CreateProgramAffiliate {
  sourceId: ID!
  scheduledDay: DayOfWeek!
  startDateTime: DateTime!
  stopDateTime: DateTime!
  startTime: Time!
  stopTime: Time!
}

input CreateRecurringSchedulePart {
  repeatIntervalUnit: IntervalUnit!
  repeatInterval: Int!
  durationSeconds: Int

  # Time of day, required for repeat interval unit in days.
  startTime: Time
}

input CreateSavedSearch {
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSON!
}

input CreateScheduledJob {
  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]
  jobTemplates: [CreateJobTemplate!]
  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]
  name: String!

  # A detailed description. Defaults to name.
  description: String
  runMode: RunMode = Once

  # JSON containing metadata details for this scheduled job.
  # If supplied, then the detailsSchemaId must also be set.
  # The supplied data must comply with the schema
  details: JSON

  # Schema ID for detail metadata on this scheduled job
  detailsSchemaId: ID
  isActive: Boolean = true
  startDateTime: DateTime
  stopDateTime: DateTime

  # Optionally, associate content templates with the new scheduled job
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  # Organization ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  organizationId: ID

  # Application ID. Used only by Veritone platform components.
  # Other clients should not attempt to send this field. Any value sent
  # will be ignored.
  applicationId: ID

  # Indicates whether or not the scheduled job is publicly accessible.
  # Only Veritone administrators can create public scheduled jobs.
  # Other users will get an error if they attempt to set this value to true.
  isPublic: Boolean = false
  affiliates: [CreateProgramAffiliate!]
}

input CreateScheduledJobCollaborator {
  # ID of the organization to share the source with
  organizationId: ID!

  # Permission to grant. Can be `editor` or `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetScheduledJobPermission!
}

input CreateScheduledJobContentTemplate {
  # Specify the scheduled job ID that this content template applies to
  scheduledJobId: ID!

  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!

  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID

  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSON
}

input CreateScheduledJobContentTemplateWithScheduledJob {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!

  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID

  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSON
}

# Data used to create a new source
input CreateSource {
  # The source type ID
  sourceTypeId: ID!

  # The human-readable source name. The value does not have to be unique,
  # but it is strongly recommended to use a name that is unique within
  # the owning organization.
  name: String!

  # Indicates whether or not the source is public. Default is false (private
  # to owner organization).
  isPublic: Boolean = false

  # Additional metadata to associate with the source. This data may be
  # validated against a schema associated with the source type.
  details: JSON

  # Optional thumbnail image URL for the source
  thumbnailUrl: String

  # Optionally, associate content templates with the new source
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  # Optionally associate a schema for correlation.
  # Required when correlationSDOId is specified.
  correlationSchemaId: ID

  # Optionally associate a structured data object of the specified correlationSchemaId.
  # Required when correlationSchemaId is specified.
  correlationSDOId: ID

  # Add or modify collaborators on the source.
  collaborators: [CreateSourceCollaborator!]

  # Optionally, set an initial state for the source.
  # This is typically not required.
  state: JSON
}

input CreateSourceCollaborator {
  # ID of the organization to share the source with
  organizationId: ID!

  # Permission to grant. Can be `editor` or `viewer`.
  # Set to `none` to revoke permissions for this organization.
  permission: SetSourcePermission!
}

input CreateSourceContentTemplate {
  # Specify the source ID that this content template applies to
  sourceId: ID!

  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!

  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID

  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSON
}

input CreateSourceContentTemplateWithSource {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!

  # To associate an existing structured data object (SDO) to the
  # source, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID

  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSON
}

input CreateSourceType {
  sourceSchemaId: ID
  credentialSchemaId: ID
  name: String!
  details: JSON
  credentialType: CredentialType = None

  # Indicates that the source type is publicly accessible.
  # If false, is usable only by the owner organization.
  isPublic: Boolean

  # Indicates whether or not the source type is "live", such
  # as a camera feed
  isLive: Boolean

  # Indicates whether or not the source type requires
  # scan pipeline jobs
  requiresScanPipeline: Boolean = false

  # Source type category ID
  categoryId: ID!
}

input CreateStructuredData {
  # Optionally provide a forced ID
  id: ID

  # Id of the schema used to validate this object
  schemaId: ID!
  data: JSON
  dataString: String
}

input CreateSubscription {
  # ID of the object (probably a watchlist) to create a subscription for
  targetId: ID!
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

input CreateSubscriptionContact {
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

# Used to create a subscription while creating a watchlist.
# The subscription will be for the new watchlist.
input CreateSubscriptionInWatchlist {
  objectType: SubscriptionObjectType = mention
  contact: CreateSubscriptionContact!
  frequency: SubscriptionFrequency = daily
  scheduledDay: DayOfWeek
  scheduledTime: Time
  scheduledTimeZone: String = "GMT"
}

# Fields required to create a task. Used when creating a job.
input CreateTask {
  # The task type, which is mapped on the server to an engine ID.
  # Either taskType OR engineId is required.
  taskType: String

  # Engine ID to be used for the task.
  # Either engineId OR taskType is required.
  engineId: ID

  # Task payload in raw string form.
  # Optional. Only one of payloadString and payload is permitted.
  payloadString: String

  # Task payload in GraphQL format.
  # Optional. Only one of payloadString and payload is permitted.
  payload: JSON

  # Optional. Specifies whether or not the task target should be cloned.
  isClone: Boolean

  # Optional. Specifies the build ID of the engine
  buildId: String

  # Optional. Specifies whether the task is for testing.
  testTask: Boolean

  # Optionally, provide a task definition that will be executed if
  # and only if this one fails. Standby tasks can be nested.
  standbyTask: CreateTask
}

input CreateTaskLog {
  # ID of the task which the task long belongs to.
  taskId: ID!

  # A file to upload. Use multipart form POST to submit this field.
  file: UploadedFile
}

input CreateTaskTemplate {
  engineId: ID
  engineConfigId: ID
  executionLocationId: ID
  jobTemplateId: ID
  payload: JSON
  payloadString: String
  parentTaskId: ID
}

# Payload required to create a temporal data object
input CreateTDO {
  # Start date and time. ISO-8601 standard strings
  # and numerical format in either Unix format (seconds
  # since epoch) or milliseconds since epoch are accepted.
  startDateTime: DateTime!

  # Stop date and time. ISO-8601 standard strings
  # and numerical format in either Unix format (seconds
  # since epoch) or milliseconds since epoch are accepted.
  stopDateTime: DateTime!

  # Source for the TDO, such as an ingestion type or engine ID.
  source: String

  # Status, such as "downloaded" or "recording".
  # The server will set a value if one is not provided.
  status: String = "downloaded"

  # A name for the TDO object, such as the name of the primary media file.
  name: String

  # A description for the TDO object.
  description: String

  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean

  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID

  # Optionally, set source data for this TDO. Source data identifies
  # that task that generated this TDO. If the TDO was not generated as part
  # of engine or adapter execution, this field should not be set.
  # However, it is _strongly_ recommended that engines that create TDOs
  # set this field. Doing so ensures that later tasks in the same job
  # have appropriate access to the new TDO.
  sourceData: SetTDOSourceData
  details: JSON

  # Only internal systems can set this value
  applicationId: ID

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String

  # An optional preview asset URL for the TDO
  previewUrl: String

  # An optional image representing the TDO source
  sourceImageUrl: String

  # Optionally, provide information to create one or more assets.
  assets: [CreateAssetInTDO!]
}

input CreateTDOContentTemplateWithTDO {
  # Supply the ID of the data registry that contains the schema
  # for the content template.
  schemaId: ID!

  # To associate an existing structured data object (SDO) to the
  # TDO, provide the SDO ID. Either this field or data must be supplied.
  sdoId: ID

  # To create a new structured data object, supply this field with
  # JSON to save in the SDO. The JSON must comply with the schema
  # defined in data registry.
  data: JSON
}

input CreateTDOForJob {
  # A name for the TDO object, such as the name of the primary media file.
  # If not provided, the TDO will have the name of the scheduled job that
  # created it.
  name: String

  # A description for the TDO object.
  description: String

  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean

  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID

  # Only internal systems can set this value
  applicationId: ID

  # Status, such as "downloaded" or "recording".
  # The server will set a value if one is not provided.
  status: String

  # Detailed metadata about the TDO
  details: JSON

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String

  # An optional preview asset URL for the TDO
  previewUrl: String

  # An optional image representing the TDO source
  sourceImageUrl: String
}

# Payload required to create a temporal data object
input CreateTDOInJob {
  # Start date and time. ISO-8601 standard strings
  # and numerical format in either Unix format (seconds
  # since epoch) or milliseconds since epoch are accepted.
  startDateTime: DateTime

  # Stop date and time. ISO-8601 standard strings
  # and numerical format in either Unix format (seconds
  # since epoch) or milliseconds since epoch are accepted.
  stopDateTime: DateTime

  # Status, such as "downloaded" or "recording".
  # The server will set a value if one is not provided.
  status: String = "downloaded"

  # A name for the TDO object, such as the name of the primary media file.
  name: String

  # A description for the TDO object.
  description: String

  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean

  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID

  # Optionally, set source data for this TDO. Source data identifies
  # that task that generated this TDO. If the TDO was not generated as part
  # of engine or adapter execution, this field should not be set.
  # However, it is _strongly_ recommended that engines that create TDOs
  # set this field. Doing so ensures that later tasks in the same job
  # have appropriate access to the new TDO.
  sourceData: SetTDOSourceData
  details: JSON

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String

  # An optional preview asset URL for the TDO
  previewUrl: String

  # An optional image representing the TDO source
  sourceImageUrl: String

  # Optionally, provide information to create one or more assets.
  assets: [CreateAssetInTDO!]
}

input CreateTDOWithAsset {
  # TDO status, such as "recorded" (the default)
  status: String = "recorded"

  # A name for the TDO object, such as the name of the primary media file.
  name: String

  # Start date and time for the file
  startDateTime: DateTime!

  # Stop date and time. If not passed, the server
  # will apply a value based on the default
  # chunk size of 15 minutes.
  stopDateTime: DateTime

  # determine stopDateTime based on the length of the media asset
  updateStopDateTimeFromAsset: Boolean = false

  # The ingestion source ID for this file
  sourceId: ID

  # Content type for the file.
  # Default is "video/mp4"
  contentType: String = "video/mp4"

  # The file location or URI.
  uri: String
  file: UploadedFile

  # Deprecated - use scheduledJobId
  scheduleId: ID

  # The scheduled job ID.
  scheduledJobId: ID

  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean

  # An optional parent folder ID for the new TemporalDataObject.
  # The folder can be filed in additional folders later using `fileTemporalDataObject`,
  # or un-filed from this one.
  parentFolderId: ID

  # Asset type. Default is "media".
  # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
  assetType: String = "media"

  # Optionally, set source data for this TDO. Source data identifies
  # that task that generated this TDO. If the TDO was not generated as part
  # of engine or adapter execution, this field should not be set.
  # However, it is _strongly_ recommended that engines that create TDOs
  # set this field. Doing so ensures that later tasks in the same job
  # have appropriate access to the new TDO.
  # This source data will be set on both the TDO and the asset.
  sourceData: SetTDOSourceData
  details: JSON

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # Optionally, add the new data to the search index. If the data is not
  # indexed on creation, it can be indexed later by using `updateTDO` or
  # creating a suitable job.
  addToIndex: Boolean = false

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String

  # An optional preview asset URL for the TDO
  previewUrl: String

  # An optional image representing the TDO source
  sourceImageUrl: String
}

input CreateTriggers {
  #  List of events in csv form. Use "*" to listen to all events. When using a wild card, csv form is no longer valid.
  #  Either events or types can be specified at a time. Example:
  #
  #  events: "event1,event2,event3" // valid
  #
  #  events: "*" // valid
  #
  #  events: "*,event1" // invalid
  events: String

  #  List of events in csv form. Use "*" to listen to all types. When using a wild card, csv form is no longer valid.
  #  Either events or types can be specified at a time. Example:
  #
  #  types: "type1,type2,type3" // valid
  #
  #  types: "*" // valid
  #
  #  types: "*,type1" // invalid
  types: String

  # Array of hook targets
  targets: [CreateTriggerType]
}

enum CreateTriggerTarget {
  #  Webhook target should provide the following kvp in the json structure of
  #  TargetType:params
  #
  #  "url":"<protocol>://<your_url>"
  Webhook

  #  SMS target should provide the following kvp in the json structure of
  #  TargetType:params
  #
  #  "number": ########
  SMS

  #  Email target should provide the following kvp in the json structure of
  #  TargetType:params
  #
  #  "address":"<your_address>@<your_domain>"
  Email
}

input CreateTriggerType {
  # The name of the trigger target. Currently we only support
  # Webhook, SMS, and Email
  name: CreateTriggerTarget!

  # The parameters for this hook. Must be a JSON payload. See
  # HookTarget docs for supported kvp for each HookTarget type.
  params: JSON!
}

input CreateUser {
  name: String!

  # Metadata in JSON format. If a field is provided elsewhere in the
  # payload, it does not need to be saved in jsondata.
  jsondata: JSON

  # User who requested that the new user be provisioned
  requestorId: ID

  # Password for new user. Optional - if not provided, the user will
  # need to set on first login.
  password: String
  organizationId: ID!
  sendNewUserEmail: Boolean
  email: String
  roleIds: [ID!]
  acls: [UserACLInput!]

  # Optionally, specify user's first name
  firstName: String

  # Optionally, specify user's last name
  lastName: String
}

input CreateWatchlist {
  # Date and time at which the watchlist becomes effective.
  # If not provided, defaults to current time.
  startDateTime: DateTime

  # Date and time at which the watchlist expires and is no longer effective.
  stopDateTime: DateTime!
  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]
  name: String!
  sourceTypeIds: [ID!]

  # Optional ID for a folder the watchlist should be filed in
  parentFolderId: ID
  sourceIds: [ID!]

  # Set structured metadata on the watchlist.
  # The data is subject to a set of schemas.
  details: JSON
  searchIndex: SearchIndex = global
  subscriptions: [CreateSubscriptionInWatchlist!]
}

input CreateWeeklySchedulePart {
  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time
}

input CreateWidget {
  collectionId: ID!
  folderId: String
  name: String
  adScript: String = ""
  width: Int = 600
  numberOfMentionsToShow: Int = 10
  displayLogo: Boolean = false
  displayCollectionName: Boolean = false
  displayMentionIntro: Boolean = false
  displayTranscription: Boolean = false
  displayCollectionDescription: Boolean = false
  displayMentionDescription: Boolean = false
  seoTags: [String] = []
  backgroundColor: String = "FFFFFF"
  borderColor: String = "D8D8D8"
  textColor: String = "000000"
  nextButtonColor: String
}

input CreateWorkflowRuntimeStorageData {
  # Unique lookup id for the workflowRuntimeData
  storageKey: String!

  # Data content - base64 encoded binary, plain string or encoded JSON
  storageData: String!

  # Optional metadata for the workflowRuntimeData
  storageMetadata: String
}

type Creative {
  id: ID!
  name: String!
  keywords: String
  organizationId: ID!
  advertiserId: ID
  brandId: ID
}

enum CredentialType {
  None
  Any
  APIKey
  Username
}

type DailyTaskMetrics {
  # The date when the tasks run
  date: String!

  # The number of tasks created in this date
  taskCount: Int!

  # The storage in bytes used by these tasks
  storageBytes: Int!

  # The media length in seconds associated with these tasks
  mediaSecs: Int!
}

type DailyTaskMetricsList {
  records: [DailyTaskMetrics!]!
}

# Analytics Dashboards
type Dashboard {
  # The order in which to display the dashboard.
  index: Int
  title: String
  description: String

  # The status of the dashboard
  active: Boolean

  # The filters that can be applied on the dashboard. Typically watchlists.
  filters: [String]
  type: String

  # Vendor specific identifier for Qlik applications
  qlikAppId: String

  # Vendor specific identifier for Qlik sheet
  qlikSheetId: String
  thumbnail: String
}

type DataRegistry {
  id: ID!
  name: String
  description: String
  source: String
  schemas(status: [SchemaStatus], majorVersion: Int, id: ID, offset: Int = 0, limit: Int = 30, orderBy: [SchemaOrder]): SchemaList

  # The organization that owns this data registry.
  organization: Organization
  organizationId: ID
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  # The currently published schema version for convenient access.
  # This field will be empty if there is no published schema.
  publishedSchema: Schema
  ingestionToken: String
}

type DataRegistryList implements Page {
  records: [DataRegistry]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum DataRegistryOrderBy {
  name
  source
  createdDateTime
  modifiedDateTime
}

input DataRegistryVersion {
  # The id of the DataRegistry
  id: ID!

  # The major version of the DataRegistry
  majorVersion: Int! = 1
}

type DatasetConfidence {
  # Mininum Confidence Filter. Sources with confidence lower than this will be ignore
  min: Float

  # Maximum Confidence Filter. Sources with confidence higher than this will be ignore
  max: Float

  # allow sources with null confidence values
  allowNull: Boolean
}

# Date/time custom scalar type
scalar DateTime

enum DayOfWeek {
  Sunday
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
}

input DeleteBuild {
  id: ID!
  engineId: ID!
}

input DeleteContextMenuExtension {
  # The ID of the context menu extension to delete
  id: ID!
}

# Delete a folder
input DeleteFolder {
  # ID of the folder to delete
  id: ID!
  orderIndex: Int!
}

type DeleteIntegrationConfigPayload {
  organizationId: ID!
  integrationId: String!
  message: String
}

input DeleteLibraryDataset {
  # Id of the selected library
  libraryId: ID!

  # List of tdo ids to remove to the selected library
  tdoIds: [ID]!
}

type DeleteLibraryDatasetPayload {
  # Id of the selected library
  libraryId: ID

  # List of tdos removed from dataset library
  tdoIds: [ID]

  # Delete status
  message: String
}

input DeleteMentionComment {
  mentionId: ID!
  commentId: ID!
}

# Input required to delete a mention rating.
# Both the rating and mention IDs must be provided.
# Only the rating will be deleted.
input DeleteMentionRating {
  # The mention ID
  mentionId: ID!

  # The rating ID
  ratingId: ID!
}

input DeleteOrganizationIntegrationConfig {
  organizationId: ID!
  integrationId: String!
}

# Payload required to delete an object
type DeletePayload {
  # ID of the object that was deleted
  id: ID!

  # a message
  message: String
}

input DeleteStructuredData {
  id: ID!

  # Id of the schema used to validate this object
  schemaId: ID!
}

# Deployment models describe how an engine or application operates on the network
# and where the data it works with is transmitted. See Veritone's developer
# documentation at https://steel-ventures.atlassian.net/wiki/spaces/VDH/pages/101364981/Engine+Deployment+Models
# for a full description.
enum DeploymentModel {
  # The engine or application is fully isolated and does not call out to any
  # external endpoints. Numerical code 0.
  FullyNetworkIsolated

  # The engine or application does not transmit data about its payload over the internet,
  # but may still make external network calls for limited purposes. Numerical code 1.
  MostlyNetworkIsolated

  # The engine or application is not network isolated and must call out to external services
  # and transmit data about its payload. Numerical code 2.
  NonNetworkIsolated

  # Human review of engine results is required. Numerical code 3.
  HumanReview
}

input EmitAuditEvent {
  # The application that created the audit log
  application: String

  # The contents of the audit log
  payload: JSON!
}

input EmitEvent {
  # Event name
  eventName: String!

  # Existing event type
  eventType: String!

  # Identifier of the app using the event
  application: String!

  # string payload, it should be serialized Protobuf data with base64 encoding or escaped JSON string
  payload: String!
}

type EmitEventResponse {
  id: ID!

  # the decoder that GQL used to interpret your event before sending
  decoder: String!
}

input EmitSystemEvent {
  # A topic
  topic: String!

  # The event payload
  payload: JSON!
}

type Engine {
  id: ID!
  ownerOrganizationId: ID!
  isPublic: Boolean
  logoPath: String
  iconPath: String

  # The signed URL for the engine icon; will fallback to raw iconPath if unable to sign.
  signedIconPath: String

  # The signed URL for the engine logo; will fallback to raw logoPath if unable to sign.
  signedLogoPath: String
  name: String
  ownerOrganization: Organization
  description: String
  categoryId: String
  state: EngineState
  price: Int
  asset: String
  displayName: String
  validateUri: String
  executeUri: String
  applicationId: ID

  # True if the engine creates a TemporalDataObject (TDO) as part of its
  # execution. False otherwise.
  createsTDO: Boolean
  website: String
  rating: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  # True if the engine requires a library to run. If so, a library ID must
  # be provided in the engine payload.
  libraryRequired: Boolean
  deploymentModel: DeploymentModel
  tasks(
    status: [String]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    id: ID

    # Filter the tasks by date/time field.
    # If a filter is not provided, a default of `createdDateTime` between
    # three months ago and the current date will be applied.
    dateTimeFilter: [TaskDateTimeFilter]
    hasSourceAsset: Boolean
  ): TaskList

  # Retrieve builds for the engine.
  # By default, deleted builds are not included.
  # Deleted builds can be retrieved by including the `deleted` status parameter.
  builds(
    buildStatus: [BuildStatus!]
    status: [String]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    id: ID
  ): BuildList

  # Dependency information for this engine
  dependency: EngineDependency

  # The list of custom fields on the engine. Users will be prompted to
  # set or change these values when they run the engine. For example, a
  # translation engine might have a field for the target language.
  fields: [EngineField!]

  # The engine category
  category: EngineCategory
  validStateActions: [EngineStateAction]

  # Get the engine's preferred input format, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  preferredInputFormat: String

  # Get the engine's supported input formats, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  supportedInputFormats: [String!]

  # Get the engine's output formats, based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  outputFormats: [String!]

  # List of IDs of source types that the engine supports,
  # based on the latest deployed build.
  # If there is no deployed build this field cannot be populated.
  # Applies only to adapter engines that ingest data from a source.
  # Will be a list of IDs of SourceType objects.
  supportedSourceTypes: [String!]

  # Get the ingestion flag which determines whether the adapter has a scan phase during ingestion.
  # If there is no deployed build this field cannot be populated.
  hasScanPhase: Boolean

  # Get the deployed build version of this engine. If there is no deployed
  # build, this field will be null.
  deployedVersion: Int

  # Specifies the mode in which the engine process input
  mode: EngineMode

  # Specifies the runtime type, such as "iron" or "edge"
  runtimeType: String

  # Get oauth information based on the deployed build. If there is no deployed
  # build, this field will be null.
  oauth: String

  # Get engine flag which determines whether the engine is a conductor,
  # this field will be null
  isConductor: Boolean

  # List of schedule types that the engine supports,
  # based on the latest deployed build.
  # If there is no deployed build, this field cannot be populated.
  supportedScheduleTypes: [EngineScheduleType!]

  # Retrieve task metrics for the engine
  taskMetrics(
    # Provide a starting date in ISO format (maximum range of 7 days)
    fromDateTime: DateTime

    # Provide an end date in ISO format (maximum range of 7 days)
    toDateTime: DateTime
  ): EngineTaskMetrics

  # List of use cases the engine serves
  useCases: [String!]

  # List of industries where the capabilities of the engine can be applied
  industries: [String!]

  # Generic Manifest for the engine based on data supplied during onboarding
  manifest: JSON
}

type EngineBlacklist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

type EngineCategory {
  id: ID!
  name: String
  description: String
  type: EngineType

  # The engine class the engine category belongs to
  class: EngineClass
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  # The list of IDs of engines in this category
  engineIds: [ID!]
  totalEngines: Int
  iconClass: String
  editable: Boolean
  videoOnly: Boolean
  color: String

  # The list of engines in this category
  engines(
    offset: Int = 0
    limit: Int = 30

    # Filters for engine attributes
    filter: EngineFilter

    # Provide a list of EngineSortField to sort by.
    orderBy: [EngineSortField]
  ): EngineList

  # If the engine category is integrated with libraries, this field contains
  # the list of IDs of entity identifier types that the engine category is compatible
  # with.
  libraryEntityIdentifierTypeIds: [ID!]

  # If the engine category is integrated with libraries, this field contains
  # the list of entity identifier types that the engine category is compatible
  # with.
  libraryEntityIdentifierTypes: EntityIdentifierTypeList

  # A type for the engine category. Multiple engine categories with common
  # elements can share a categoryType. This information is used to compute
  # dependencies and format user interface elements.
  categoryType: String

  # An optional key used to identify this engine category's results for
  # search and other purposes.
  # Primarily used by Veritone platform applications.
  categoryMetadataKey: String

  # A list of categoryTypes on which instances of this engine category depend.
  dependencies: [EngineDependency!]

  # Information about how engine results in this category can be searched
  # in Veritone platform applications.
  # Used primarily by Veritone platform applications.
  searchConfiguration: EngineSearchConfiguration

  # List of engine result export formats supported by engines in this
  # category. May be empty.
  exportFormats: [ExportFormat]!
}

type EngineCategoryList implements Page {
  records: [EngineCategory!]
  offset: Int!
  limit: Int!
  count: Int
}

type EngineClass {
  id: ID!
  name: String
  description: String
  iconClass: String
}

type EngineClassList implements Page {
  records: [EngineClass!]
  offset: Int!
  limit: Int!
  count: Int
}

type EngineConfiguration {
  id: ID!
  credentials: [ExternalCredential!]
  sourceId: ID
  source: Source
}

type EngineConfigurationList implements Page {
  records: [EngineConfiguration!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type EngineDependency {
  # TODO maps to values in engineCategory.data_field?
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String!

  # Asset type to expect previous engine to produce
  assetType: String

  # The engine category corresponding to this dependency
  category: EngineCategory
}

# Represents a custom input field on an engine.
type EngineField {
  # Maximum value, in float format. Applies only to fields of type Number.
  max: Float

  # Minimum value, in float format. Applies only to fields of type Number.
  min: Float

  # Numerical step by which the value should be incremented or decremented in
  # the user interface, in float format. Applies only to fields of type Number.
  step: Float

  # The field type.
  type: EngineFieldType!

  # General information about the field, such as a description.
  info: String

  # A machine-readable name, or key, for the field.
  name: String!

  # A human-readable label for the field.
  label: String

  # A set of allowed values for the field. Applies only to fields of type
  # picklist or multi-picklist.
  options: [EngineFieldPicklistOption!]

  # An optional default value for the field. Taken in string format, but
  # applies to all field types.
  defaultValue: String

  # Optional default values to apply to a picklist. This field
  # should only be set for a field of type multi-picklist.
  defaultValues: [String!]

  # specifies whether the field is optional
  required: Boolean
}

# Represents one allowed option in a picklist.
type EngineFieldPicklistOption {
  # The human-readable label for the option, such as "English-US" for a language selector.
  key: String!

  # The machine-readable value that will be sent in the engine payload, such as
  # "en-us" for a language selector.
  value: String!
}

# An enum containing valid custom engine field types.
enum EngineFieldType {
  # A number, in float format
  Number

  # A pick list that allows the user to choose one of a set of allowed values.
  Picklist

  # A pick list that allows the user to choose any number of a set of allowed values.
  MultiPicklist

  # A plain text field
  Text

  # A dynamic list of schemas that will be populated by the client
  SchemaSelection
}

input EngineFilter {
  # Name of engine to filter by
  name: String

  # Provide a list of engine states to filter by
  state: [EngineState!]

  # Language supported by the engine
  language: String

  # Provide a list of engine category names to filter by
  category: [String!]

  # Filter engines that require a library
  libraryRequired: Boolean

  # Provide a list of engine type names to filter by
  type: [EngineTypeFilter!]

  # Provide a list of rating from 0 to 5 to filter by.
  rating: [Int]

  # Specify the deployment model of the engine.
  deploymentModel: DeploymentModel

  # Provide a list of deployment models to filter by
  deploymentModels: [DeploymentModel!]

  # Specify the minimum price of the engine.
  priceMin: Int

  # Specify the maximum price of the engine.
  priceMax: Int

  # Specify the minimum FedRamp impact level of the engine.
  fedRampImpactLevelMin: Int

  # Specify the minimum FedRamp impact level of the engine.
  fedRampImpactLevelMax: Int

  # Filter engines that can be trainable via API.
  trainableViaApi: Boolean

  # Filter engines by cluster size.
  clusterSize: ClusterSize

  # Provide a list of cluster sizes to filter by
  clusterSizes: [ClusterSize!]

  # Filter engines by gpu supported.
  gpuSupported: SupportedGPU

  # Provide a list of supported gpus to filter by
  gpusSupported: [SupportedGPU!]

  # Provide a list of engine modes to filter by
  mode: [EngineMode!]

  # Provide a list of engine runtime types to filter by
  runtimeType: [String!]

  # Provide a list of supported input formats to filter by
  supportedInputFormats: [String!]

  # Filter engines by max media length in ms
  maxMediaLengthMs: Int
}

# Contain resouces of Engine JWT Token
type EngineJWTResource {
  applicationId: ID
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

type EngineList implements Page {
  records: [Engine]

  # Number of records returned in this response
  count: Int!

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!
}

enum EngineMode {
  Chunk
  Stream
  Batch
}

enum EngineOrderField {
  name
  id
  state
  price
  rating
  order
  createdDateTime
  modifiedDateTime
  runtimeType
  category
  type
  deploymentModel
  mode
  libraryRequired
  buildCreatedDateTime
  clusterSize
  gpuSupported
  maxMediaLengthMs
}

# Represents single chunk of engine results for date range
type EngineResult {
  tdoId: ID!
  engineId: ID!
  jsondata: JSON
  startOffsetMs: Int
  stopOffsetMs: Int
  assetId: String
  userEdited: Boolean
  tdo: TemporalDataObject
  taskId: ID
  libraryId: ID
  library: Library
}

# Represents a collection of engine results. Not Paged.
type EngineResultList {
  sourceId: ID
  records: [EngineResult]
}

# Describes engine run on a TDO with
type EngineRun {
  # Engine that was run on a TDO
  engine: Engine

  # Engine status derived from the written engine output or task status. See TaskStatus enum for details.
  status: TaskStatus

  # Last run task for this engine and tdo
  task: Task

  # Whether or not the engine run has user edits
  hasUserEdits: Boolean
}

type EngineRunList implements Page {
  records: [EngineRun]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum EngineScheduleType {
  Now
  OnDemand
  Recurring
  Continuous
}

# Represents configuration on how the results of engines within a given
# category are indexed and searched.
# Primarily used by Veritone platform applications.
type EngineSearchConfiguration {
  # Autocomplete field information is used to tell client applications
  # what fields are searchable by autocomplete in the search index and
  # how to search for them.
  autocompleteFields: [AutocompleteFieldConfig!]

  # Autocomplete field information is used to tell client applications
  # what fields are searchable in the search index and
  # how to search for them.
  searchFields: [SearchFieldConfig!]

  # Indicates whether or not search is available for results produced
  # by engines in this category can be searched.
  isSearchEnabled: Boolean

  # Indicates whether or not search is available for results produced
  # by engines in this category can be searched within the Elasticsearch index.
  isElasticEnabled: Boolean
  searchMetadataKey: String
  elasticType: String
}

input EngineSortField {
  field: EngineOrderField!
  direction: OrderDirection
}

# Enumeration containing the set of allowed values for the Engine state field.
enum EngineState {
  # The engine is deployed and active. Set the state to this value to deploy it.
  active

  # The engine has been disabled. Set this state to disable the engine.
  disabled

  # The engine is awaiting approval before transitioning to the next state.
  pending

  # The engine has been deleted and is no longer available for use.
  deleted

  # The engine is in draft state, suitable for review and internal testing.
  draft

  # The engine is ready for deployment, but has not been deployed yet.
  ready
}

enum EngineStateAction {
  edit
  delete
  disable
  enable
  undelete
}

type EngineTaskMetrics {
  cancelledCount: Int
  completedCount: Int
  failedCount: Int
  pendingCount: Int
  queuedCount: Int
  runningCount: Int
}

type EngineType {
  name: String
  description: String
}

enum EngineTypeFilter {
  Cognition
  Ingestion
  Aggregator
}

type EngineWhitelist {
  organizationId: ID!
  engines: [Engine]
  engineCategories: [EngineCategory]
}

input EngineWorkflow {
  id: ID!
  action: EngineWorkflowAction!
}

enum EngineWorkflowAction {
  enable
  disable
}

type Entity {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String
  properties: [Property]
  libraryId: ID
  library: Library
  profileImageUrl: String
  identifiers(
    # Provide an ID to retrieve a specific entity identifier
    id: ID
    identifierTypeId: ID
    offset: Int = 0
    limit: Int = 30
  ): EntityIdentifierList
  isPublished: Boolean
  jsondata: JSON
  jsonstring: String
  summary: EntitySummary
  description: String
}

type EntityIdentifier {
  id: ID!
  entityId: ID!
  entity: Entity!
  identifierType: EntityIdentifierType!
  identifierTypeId: ID!
  title: String
  isPriority: Boolean
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  url: String!
  contentType: String!
  jsondata: JSON
  jsonstring: String
}

enum EntityIdentifierDataType {
  image
  audio
  video
  text
  pdf
  tdo
  objectbox
}

type EntityIdentifierItem {
  libraryTypeId: String!
  entityIdentifierTypeId: String!
  minItems: Int
  maxItems: Int
}

type EntityIdentifierItemList {
  records: [EntityIdentifierItem]
  limit: Int!
  offset: Int!
  count: Int
}

type EntityIdentifierList implements Page {
  records: [EntityIdentifier]
  offset: Int!
  limit: Int!
  count: Int
}

type EntityIdentifierType {
  id: ID!
  label: String!
  labelPlural: String!
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType!
  entityIdentifierItems: [EntityIdentifierItem]
}

type EntityIdentifierTypeList implements Page {
  records: [EntityIdentifierType!]
  limit: Int!
  offset: Int!
  count: Int
}

type EntityList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
  records: [Entity]
}

type EntitySummary {
  identifierCountsByType: JSON
}

type EntityType {
  name: String!
  namePlural: String!
  schema: JSON!
}

type Event {
  id: ID!
  eventName: String!
  eventType: String!
  application: String!
  public: Boolean!
  description: String
  schemaData: String!
  schemaHash: String!
  createdDateTime: DateTime!
  createdBy: String!
}

type EventActionTemplate {
  id: ID!

  # The name of template.  e.g. "Run engine X for every new mention in a watchlist".
  name: String!

  # owner of the template
  organizationId: ID!

  # Application this template could be applied to.  If application_id is null, then this is an org-wide template.
  ownerApplicationId: ID

  # use "event" for now.  In the future, we allow additional input_type types.  For example, a schedule or a tweet.
  inputType: EventActionTemplateInputType!

  # based on the input_type, input_validation describes additional validations. 
  # For example, if input_type is "event", input_validation could be a list of
  # allowed events.
  inputValidation: JSON

  # A JSON structure that is compatible/specific to the input_type.  For example,
  # if input type is "event", then input_attributes simply contain the entire event payload.
  inputAttributes: JSON

  # Either "job", "webhook", "sms", "email".  Future action_type could be "gql" where action is purely a function call.
  actionType: EventActionTemplateActionType!

  # Allows you to specify validation for the action_type.  For example, if
  # action_type is "job", perhaps only whitelist a list of engines that could be called.
  actionValidation: JSON

  # dedicated column to specify where/what the action is taking place.  For
  # example, if action is a job, then destination is an engine_id.  For webhook, a uri.
  actionDestination: String!

  # A JSON structure that is compatible with action_type.  For example, if
  # action_type is "webhook", action_attributes contain the mustache compatible
  # template to format the content.  If action_type is "job", then
  # action_attributes need to specify a job template.
  actionAttributes: JSON
}

enum EventActionTemplateActionType {
  job
  sms
  email
  webhook
  gql
}

enum EventActionTemplateInputType {
  event
}

type EventActionTemplateList implements Page {
  records: [EventActionTemplate]
  count: Int
  offset: Int!
  limit: Int!
}

input EventDelivery {
  name: EventDeliveryType!
  params: JSON!
}

enum EventDeliveryType {
  # Webhook protocol should provide the following kvp in the json structure of
  # "url":"<protocol>://<your_url>"
  # "encoding":"[protobuf|protobuf_base64|json]
  # "template": string
  Webhook

  # SMS protocol should provide the following kvp in the json structure of
  # "number": ##########
  SMS

  # Email protocol should provide the following kvp in the json structure of
  # "address":"<your_address>@<your_domain>"
  Email

  # Create Job
  # "targetId": ""
  # "engineId":""
  CreateJob
}

type EventList implements Page {
  records: [Event]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type EventSubscription {
  # The event subscription id
  id: ID!

  # The organization id
  organizationId: ID!

  # The event name such as `MentionGenerated`, `JobCompleted`, etc.
  eventName: String!

  # The event type such as `mention`, `job`, etc
  eventType: String!

  # The target of the event
  targetName: String!

  # The params that will be used by the consumer of the event
  consumerParams: JSON!

  # The subscription hash
  subscriptionHash: String!

  # The created date time of the event subscription
  createdDateTime: DateTime!

  # The conditions to filter the event
  conditions: JSON
}

type EventSubscriptionList implements Page {
  records: [EventSubscription]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type ExecutionLocation {
  id: ID!
  clusterId: ID!
  cluster: Cluster!
  nodeId: ID
  node: ClusterNode
  data: JSON!
}

type ExecutionLocationList implements Page {
  records: [ExecutionLocation!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type ExportFormat {
  # The file format/extension i.e. ttml, vlf, etc.
  format: String!

  # A human readable label for the file format i.e. "Time Text Markup Language"
  label: String!

  # A list types to categories the file format by i.e. "subtitle"
  types: [String]!
}

type ExportRequest {
  # The unique ID of this export request
  id: ID!

  # Current status of this export request
  status: ExportRequestStatus!

  # ID of the organization this export request was issued for
  organizationId: ID!

  # Date/time at which this export request was created
  createdDateTime: DateTime!

  # Date/time at which this export request was last modified
  modifiedDateTime: DateTime!

  # ID of the user or API key that created this export request
  requestorId: ID!

  # The signed URI to the object that contains, or will contain,
  # export results.
  assetUri: String
}

enum ExportRequestEvent {
  exportRequest
  mentionExportRequest
}

type ExportRequestList implements Page {
  records: [ExportRequest!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum ExportRequestStatus {
  incomplete
  complete
  downloaded
  failed
}

type ExternalCredential {
  id: ID!
  sourceTypeId: ID
  sourceType: SourceType
  data: StructuredData
  dataId: ID
}

type ExternalCredentialList implements Page {
  records: [ExternalCredential!]!
  count: Int!
  offset: Int!
  limit: Int!
}

type FileData implements Metadata {
  name: String!
  size: Int
  mimeType: String
  fileName: String
}

input FileTemporalDataObject {
  # ID of the TDO to file
  tdoId: ID!

  # ID of the new parent folder
  folderId: ID!

  # Order index determining in what order the new TDO will be displayed
  # relative to other TDOs at the same level
  orderIndex: Int = 0
}

input FileWatchlist {
  # ID of the TDO to file
  watchlistId: ID!

  # ID of the new parent folder
  folderId: ID!

  # Order index determining in what order the watchlist will be displayed
  # relative to other objects at the same level
  orderIndex: Int = 0
}

type Folder {
  # The ID of this folder
  id: ID!
  treeObjectId: ID!

  # The name of this folder
  name: String

  # An optional description
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  ownerId: String

  # The parent folder
  parent: Folder

  # The subfolders of this folder
  # Deprecated: Use paginated childFolders instead.
  subfolders: [Folder!]

  # A paginated list of child folders of this folders
  childFolders(
    offset: Int = 0
    limit: Int = 30

    # Provide a list of names to filter folders
    names: [String]
  ): FolderList

  # The organization that owns this folder
  organization: Organization

  # The ID of the organization that owns this folder
  organizationId: ID
  typeId: Int
  rootFolderTypeId: Int

  # The maximum depth of child folders allowed
  maxDepth: Int
  orderIndex: Int

  # The folder status
  status: FolderStatus

  # The ordered path of the folder hierarchy. The first element
  # is always a root folder, and the last is this folder's parent.
  folderPath: [Folder!]

  # TemporalDataObjects that are filed in this folder
  childTDOs(offset: Int = 0, limit: Int = 30): TDOList

  # Watchlists that are filed in this folder
  childWatchlists(
    offset: Int = 0
    limit: Int = 30

    # Provide a name to filter watchlists
    name: String
  ): WatchlistList

  # The read/write permissions for a shared folder
  sharedAccess: [String]
  sharedWith: SharedWith
  contentTemplates: [FolderContentTemplate!]!
}

type FolderContentTemplate {
  id: ID!
  folderId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type FolderList implements Page {
  records: [Folder]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type FolderOverview {
  childFoldersCount: Int!
  childNonFolderObjectsCount: Int!
  treeObjectIds: [ID]
}

enum FolderStatus {
  active
  inactive
}

type FolderSummaryDetail {
  id: ID!
  treeObjectId: ID!
  typeId: Int
  childFoldersCount: Int!
  childNonFolderObjectsCount: Int!
  childWatchlistsIds: [String]
  createdBy: User
  depth: Int
  fingerprints: String
  marketCount: Int
  trackMyPrograms: Boolean
  mediaSourceTypeIds: [Int]
  orderIndex: Int
  parentTreeObjectId: String
  programCount: Int
  searchTerms: [String]
  trackingUnitName: String
  trackingUnitStartDate: DateTime
  trackingUnitStopDate: DateTime
  createdDateTime: DateTime!
  modifiedDateTime: DateTime
}

input GetCurrentUserPasswordToken {
  password: String
}

input getEngineJWT {
  # The ID of the engine that created the asset
  engineId: ID!

  # The set of IDs by resource type
  resource: GetEngineJWTResource!
}

input GetEngineJWTResource {
  tdoId: ID
  jobId: ID!
  taskId: ID!
}

input GetNextBundleForCluster {
  # ID of cluster need to get next bundle
  clusterId: ID!
}

# This type represents information about the Veritone GraphQL server
# instance. Primarily used by Veritone engineering and operations.
type GraphQLServiceInfo {
  # JSON structure containing build information, such as the build number and date.
  buildInfo: JSON
  featureFlags: JSON
  heartbeatStats: JSON
}

type Group {
  id: ID!
  name: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  applicationId: ID!
  createdBy: User
  modifiedBy: User
  organizationId: ID!
  organization: Organization

  # Freeform metadata in JSON form
  jsondata: JSON
}

type GroupList implements Page {
  records: [Group]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type IntegrationConfig {
  organizationId: ID!
  integrationId: String!
  config: JSON!
  userVisible: Boolean
}

enum IntervalUnit {
  Months
  Weeks
  Days
  Hours
  Minutes
  Seconds
}

# Type representing an integer property.
type IntProperty implements Property {
  name: String!
  value: Int
}

type Job {
  # ID of the job
  id: ID!

  # User-provided job name
  name: String

  # Optional job description
  description: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  # ID of the target object for the job, such as a container or Recording
  targetId: ID

  # Source asset ID
  sourceAssetId: ID

  # Overall job status, as computed from the statuses of its component tasks
  status: TaskStatus

  # Tasks the job has or will execute
  tasks(
    # Specify a list of job status strings to filter by status
    status: [TaskStatus!]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Maximum number of results to retrieve in this query
    limit: Int = 30

    # Specify an ID to retrieve a single specific task
    id: ID

    # Specify a list of IDs to filter by task target ID
    targetId: [ID]
    hasSourceAsset: Boolean
  ): TaskList

  # Application the job ran under
  applicationId: ID

  # Target TemporalDataObject
  target: TemporalDataObject

  # ID of the cluster where this job will be executed
  clusterId: ID
  jobConfig: JSON

  # ID of the template from which this job was created, if applicable.
  templateId: ID

  # The template which this job was created, if applicable.
  template: JobTemplate

  # ID of the scheduled job under which this job was created, if applicable.
  scheduledJobId: ID

  # The scheduled job under which this job was created, if applicable.
  scheduledJob: ScheduledJob
}

enum JobDateTimeField {
  createdDateTime
  modifiedDateTime
}

input JobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: JobDateTimeField!
}

type JobList implements Page {
  # Jobs retrieved
  records: [Job]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum JobOrderField {
  createdDateTime
  modifiedDateTime
}

type JobPipeline {
  # Unique ID of this job pipeline
  id: ID!

  # List of job templates associated with this job pipeline
  jobTemplates: JobTemplateList

  # ID of the organization that owns this job pipeline
  organizationId: ID

  # The organization that owns this job pipeline
  organization: Organization

  # Indicates whether or not this job pipeline is public. If so, it can
  # be viewed and used, but not modified, by all organizations.
  isPublic: Boolean!
}

type JobPipelineList implements Page {
  records: [JobPipeline!]!
  count: Int!
  offset: Int!
  limit: Int!
}

input JobSortField {
  field: JobOrderField!
  direction: OrderDirection = desc
}

enum JobStatus {
  pending
  complete
  running
  cancelled
  queued
  failed
}

enum JobStatusFilter {
  pending
  running
  complete
  cancelled
  queued
  failed
}

# A job template is a reusable template for job creation.
type JobTemplate {
  # The object ID
  id: ID!

  # Date and time this job template was created
  createdDateTime: DateTime

  # Date and time this job template was last modified
  modifiedDateTime: DateTime

  # Task templates associated with this job template
  taskTemplates(engineType: [EngineTypeFilter!], engineId: ID, offset: Int = 0, limit: Int = 30): TaskTemplateList!

  # Job pipeline ID that this template belongs to, if there is one
  jobPipelineId: ID

  # Job pipeline that this template belongs to, if there is one
  jobPipeline: JobPipeline

  # Job pipeline stage. Defined only if this template belongs to a job pipeline.
  jobPipelineStage: Int

  # Target execution cluster ID
  clusterId: ID
  skipDecider: Boolean

  # Optional configuration data for jobs launched from the template.
  # A schema may be enforced over the data stored here.
  # Used for top-level information about the job that does not fit on
  # a specific task template.
  jobConfig: JSON
}

type JobTemplateList implements Page {
  records: [JobTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type JSONObject implements Metadata {
  name: String!
  data: JSON
}

# Contains information about engineJWTToken context
type JWTTokenInfo {
  engineId: ID!
  token: String!
  resource: EngineJWTResource!
}

# Key-value pairs -- a generic way to represent metadata
type KVP implements Metadata {
  name: String!
  value: [Property]
}

input LaunchJobTemplates {
  ids: [ID!]!
  scheduledJobId: ID
  payload: JSON

  # Optional data used to create a _new_ TDO for the job.
  # Specify this field _or_ `targetInfo`, but not both.
  createTargetInfo: CreateTDOForJob
  targetInfo: LaunchJobTemplatesTargetInfo
}

input LaunchJobTemplatesTargetInfo {
  # ID of the target object for the jobs,
  # typically that of a TemporalDataObject
  targetId: ID!
  startOffsetMs: Int
  endOffsetMs: Int
}

input LaunchScheduledJobs {
  # Optional data about the job target,
  # a TemporalDataObject. If this field is
  # not specified then a suitable
  # object will be created automatically.
  targetInfo: CreateAllPipelineJobsTargetInfo

  # Optional data used to create a _new_ TDO for the job.
  # Specify this field _or_ `targetInfo`, but not both.
  createTargetInfo: CreateTDOForJob

  # Job payload
  payload: JSON
  scheduledJobId: ID
}

type Library {
  # Object creation timestamp. Does not change.
  createdDateTime: DateTime

  # Object modification timestamp.
  modifiedDateTime: DateTime

  # The object's unique ID
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String

  # Modular metadata in the form of key-value pairs
  properties: [Property]

  # Security settings for the asset container
  security: Security
  applicationId: ID!

  # Library version
  version: Int
  organizationId: ID
  libraryType: LibraryType
  libraryTypeId: ID
  coverImageUrl: String

  # Retrieve engine models for a library
  engineModels(
    # Provide an ID to retrieve a specific engine model
    id: ID

    # Provide a library version to retrieve engine models associated with
    # a given version.
    libraryVersion: Int

    # Set to true to retrieve engine models associated with the current
    # library version.
    currentVersion: Boolean

    # Provide a training status to filter for engine models by status.
    trainStatus: LibraryEngineModelTrainStatus

    # Set to true to retrieve the most recently modified engine model.
    lastModified: Boolean
  ): LibraryEngineModelList

  # Retrieve library model configurations
  configurations(limit: Int, offset: Int): LibraryConfigurationList

  # Retrieve dataset library tdos
  dataset: LibraryDataset
  entities(
    # Provide an ID to retrieve a single specific entity.
    id: ID
    ids: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList

  # Retrieve collaborators for a library.
  collaborators(
    # Provide an ID to retrieve collaborators within a specific organization.
    collaboratorOrgId: ID
  ): LibraryCollaboratorList

  # Aggregated summary data about the library
  summary: LibrarySummary
}

type LibraryCollaborator {
  organizationId: ID!
  organization: Organization
  status: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  permissions: [String]
  libraryId: ID!
  library: Library
}

type LibraryCollaboratorList {
  records: [LibraryCollaborator]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type LibraryConfiguration {
  # library configuration id
  id: ID

  # ID of the selected library where this config applies to
  libraryId: ID

  # ID of the engine category this config applies to
  engineCategoryId: ID

  # List of selected engine ids for training
  targetEngineIds: [ID]

  # This option is used for Dataset Library Only
  # List of selected engine where tdos are extracted from for training data
  # TDOs are extracted from higher ranked engines first then fallback to the lower
  # ones if the priors don't have any matching tdo
  rankedSourceEngineIds: [ID]

  # This option is used for Dataset Library Only
  # Dataset tdos confidence filters
  confidence: DatasetConfidence
}

type LibraryConfigurationList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
  records: [LibraryConfiguration]
}

type LibraryDataset {
  # Id of the selected library
  libraryId: ID

  # List of tdo ids in the selected library
  tdoIds: [ID]
}

type LibraryEngineModel {
  id: ID!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  engineId: ID!
  engine: Engine
  libraryId: ID!
  library: Library
  libraryVersion: Int
  trainJobId: ID
  trainStatus: LibraryEngineModelTrainStatus!
  dataUrl: String

  # Content type of the data file pointed to by dataUrl.
  # Will be empty if no data file is attached to the engine model.
  contentType: String
  jsondata: JSON
  accuracy: Int
  configurationId: ID
}

type LibraryEngineModelList implements Page {
  records: [LibraryEngineModel]
  offset: Int!
  limit: Int!
  count: Int
}

enum LibraryEngineModelTrainStatus {
  pending
  queued
  complete
  failed
  running
}

enum LibraryEntityOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
}

type LibraryList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
  records: [Library]
}

enum LibraryOrderBy {
  id
  name
  createdDateTime
  modifiedDateTime
  version
}

type LibrarySummary {
  entityCount: Int
  unpublishedEntityCount: Int
  lastTrainedVersion: Int
  lastTrainedDateTime: DateTime
}

type LibraryType {
  id: ID!
  label: String
  iconClass: String
  entityIdentifierTypes: [EntityIdentifierType]
  entityTypeName: String
  entityTypeNamePlural: String
  entityType: EntityType
}

type LibraryTypeList implements Page {
  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
  records: [LibraryType]
}

# Contains information about the user's authentication context.
type LoginInfo {
  # API token. This is a persistent organization-level token intended for API access.
  apiToken: String

  # Session-scoped user token. This token is tied to the user's session and will expire
  # when that session ends.
  token: String

  # Date and time at which the user last logged in to the Veritone platform
  lastLoggedIn: String

  # List of Veritone platform applications for which the user is provisioned.
  # Note that these are different than the VDA custom applications referenced
  # in the `Application` type, `applications()` query, and related mutations.
  applications: [ID]
  applicationPlatforms: [ApplicationPlatform]

  # Groups to which the user belongs.
  groups: [Group]

  # True if the user account has a password set. False otherwise.
  # If false, the user will be prompted to set a password on next login.
  hasPassword: Boolean

  # Organization to which the user belongs.
  organization: Organization

  # True if a password reset will be required on the user's next login.
  passwordResetRequired: Boolean

  # TODO
  providerId: String

  # TODO
  providerScreenName: String

  # TODO
  providerUserId: String

  # User object
  user: User
}

type MediaShare {
  mediaType: String!
  serviceName: String!

  # sourceId OR tdoId is required
  sourceId: ID
  tdoId: ID
  scheduledJobId: ID
  startDateTime: DateTime
  stopDateTime: DateTime
  startOffsetMs: Int
  stopOffsetMs: Int

  # various settings for diffrent types of media. like audio only for videos
  settings: JSON
}

type MediaShareInfo {
  token: String!
  isSegmented: Boolean
}

enum MediaStorageOption {
  edge
  core
}

type Mention {
  id: ID!
  organizationId: ID!
  sourceTypeId: ID
  sourceId: ID
  scheduleId: ID
  mediaId: ID
  advertiserId: ID
  brandId: ID
  campaignId: ID
  watchlistId: ID
  statusId: ID
  complianceStatusId: ID
  spotTypeId: ID
  audienceMarketCount: Int
  audienceAffiliateCount: Int
  mentionHitCount: Int
  audience: Int
  mentionRating: Float
  isMatch: Boolean
  mentionDate: DateTime
  metadata: JSON
  mentionSnippets: [MentionSnippets]
  userSnippets: [MentionUserSnippets]
  adCreative: JSON
  fingerprint: JSON
  cognitiveEngineResults: JSON
  comments: MentionCommentList
  hash: ID
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  endDateTime: DateTime
  scheduledJob: ScheduledJob
  temporalDataObject: TemporalDataObject
  organization: Organization!
  watchlist: Watchlist
  advertiser: JSON
  brand: JSON
  queryTerm: String
  ratings(userId: ID): MentionRatingList
  privateNote: String
  publicNote: String
  campaign: Campaign
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionComment {
  commentId: ID!
  mentionId: ID
  userId: ID
  firstName: String
  lastName: String
  userImage: String
  commentText: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionCommentList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionComment]
}

enum MentionDateTimeField {
  mentionDate
  endDateTime
  hitStartDateTime
  hitStopDateTime
}

input MentionDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: MentionDateTimeField!
}

type MentionHit {
  queryTerm: String
  startTime: Float
  endTime: Float
}

type MentionList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [Mention!]
}

input MentionOrderBy {
  field: MentionOrderByField!
  direction: OrderDirection = desc
}

enum MentionOrderByField {
  id
  mentionDate
  hitStartDateTime
  hitEndDateTime
  endDateTime
}

type MentionRating {
  ratingId: ID!
  mentionId: ID
  userId: ID
  ratingValue: Int
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type MentionRatingList implements Page {
  offset: Int!
  limit: Int!
  count: Int
  records: [MentionRating]
}

type MentionSnippets {
  text: String
  startTime: Float
  endTime: Float
  hits: [MentionHit]
}

type MentionStatus {
  id: ID!
  name: String!
}

type MentionUserSnippets {
  text: String
  startTime: Float
  endTime: Float
  transcriptStartDate: DateTime
  transcriptEndDate: DateTime
  snippets: [MentionSnippets]
}

interface Metadata {
  name: String!
}

# Type that holds multi-factor authentication for a user
type MFAInfo {
  phoneNumber: String
  smsVoiceVerifiedDateTime: DateTime
  gaVerifiedDateTime: DateTime
  defaultOption: String
  pendingRegistration: String
}

# Move a folder into a new parent folder.
input MoveFolder {
  treeObjectId: ID!
  prevParentTreeObjectId: ID!
  newParentTreeObjectId: ID!
  newOrderIndex: Int!
  prevOrderIndex: Int!
  rootFolderType: RootFolderType = watchlist
}

input MoveTemporalDataObject {
  # ID of the TDO to move
  tdoId: ID!

  # ID of the original parent folder. The TDO will be removed from this folder.
  oldFolderId: ID!

  # ID of the new parent folder. The TDO will be added to this folder.
  newFolderId: ID!
}

# Mutations are used to modify data. Each mutation takes an input
# that contains the data necessary to create or update the data
# in question.
type Mutation {
  # Create a new temporal data object
  createTDO(
    # Fields required to create a TDO
    input: CreateTDO
  ): TemporalDataObject

  # Update a temporal data object
  updateTDO(
    # Fields required to update a TDO
    input: UpdateTDO
  ): TemporalDataObject

  # Delete a temporal data object. The TDO metadata, its assets and
  # all storage objects, and search index data are deleted.
  # Engine results stored in related task objects are not.
  # cleanupTDO can be used to selectively delete certain data on the TDO.
  deleteTDO(
    # Supply the ID of the TDO to delete
    id: ID!
  ): DeletePayload

  # Delete partial information from a temporal data object.
  # Use the delete options to control exactly which data is deleted.
  # The default is to delete objects from storage and the search index,
  # while leaving TDO-level metadata and task engine results intact.
  # To permanently delete the TDO, use delete TDO.
  cleanupTDO(
    # Supply the ID of the TDO to clean up.
    id: ID!

    # Supply a list of cleanup options. See TDOCleanupOption
    # for details. If not provided, the server will use default settings.
    options: [TDOCleanupOption!] = [storage, searchIndex]
  ): DeletePayload

  # Create a task log by using
  # multipart form POST.
  createTaskLog(
    # Fields needed to create a task log.
    input: CreateTaskLog!
  ): TaskLog

  # Create a media asset. Optionally, upload content using
  # multipart form POST.
  createAsset(
    # Fields needed to create an asset.
    input: CreateAsset!
  ): Asset

  # Delete an asset
  deleteAsset(
    # Provide the ID of the asset to delete.
    id: ID!
  ): DeletePayload

  # Update an asset
  updateAsset(
    # Fields needed to update an asset.
    input: UpdateAsset!
  ): Asset

  # Add a single media segment to a TemporalDataObject.
  # This mutation will update the manifest asset (`media-mdp`)
  # for the TemporalDataObject.
  addMediaSegment(
    # Fields necesary to create the segment.
    input: AddMediaSegment!
  ): TemporalDataObject!

  # Start a clone job. A clone creates a new TDO
  # that links back to an existing TDO's assets
  # instead of creating new ones and is used
  # primarily to handle sample media.
  requestClone(
    # Fields needed to request a new clone job.
    input: RequestClone
  ): CloneRequest

  # Create a new engine. The engine will need to go
  # through a sequence of workflow steps before
  # use in production. See VDA documentation for details.
  createEngine(
    # Fields needed to create a new engine
    input: CreateEngine
  ): Engine

  # Update an engine. Engines are subject to specific
  # workflow steps. An engine's state determines what
  # updates can be made to it. See VDA documentation for
  # details.
  updateEngine(
    # Fields needed to update an engine
    input: UpdateEngine
  ): Engine

  # Delete an engine
  deleteEngine(
    # Provide the ID of the engine to delete
    id: ID!
  ): DeletePayload

  # Create an engine build.
  createEngineBuild(
    # Fields needed to create an engine build.
    input: CreateBuild!
  ): Build

  # Update an engine build. Engine builds are subject to
  # specific workflow steps. A build's state determines what
  # updates can be made to it. See VDA documentation for details.
  updateEngineBuild(
    # Fields needed to update an engine build.
    input: UpdateBuild!
  ): Build

  # Delete an engine build
  deleteEngineBuild(
    # Fields needed to delete an engine build.
    input: DeleteBuild!
  ): DeletePayload

  # Update a task
  updateTask(
    # Fields required to update a task.
    input: UpdateTask
  ): Task
  addTasksToJobs(input: AddTasksToJobs): AddTasksToJobsResponse

  # Poll a task
  pollTask(
    # Fields required to poll a task.
    input: PollTask
  ): Task

  # Create a job
  createJob(
    # Fields required to create a job.
    input: CreateJob
  ): Job

  # Cancel a job. This action effectively deletes the job,
  # although a records of job and task execution remains in
  # Veritone's database.
  cancelJob(
    # Supply the ID of the job to delete.
    id: ID!
  ): DeletePayload

  # Retry a job. This action applies only to jobs
  # that are in a failure state. The task sequence
  # for the job will be restarted in its original
  # configuration.
  retryJob(
    # Supply the ID of the job to retry.
    id: ID!
  ): Job
  updateJobs(input: UpdateJobs!): JobList

  # Create a new application. An application must
  # go through a sequence of workflow steps before
  # it is available in production. See the VDA documentation
  # for details.
  createApplication(
    # Fields needed to create a new custom application.
    input: CreateApplication
  ): Application

  # Delete an application
  deleteApplication(
    # Supply the ID of the application to delete.
    id: ID!
  ): DeletePayload

  # Update a custom application. Applications are subject to
  # specific workflows. The current application state determines
  # what updates can be made to it. See VDA documentation for details.
  updateApplication(
    # Fields required to update a custom application.
    input: UpdateApplication
  ): Application

  # Update an application by adding or removing components
  updateApplicationComponent(input: UpdateApplicationComponent!): ApplicationComponent!

  # Bulk delete context meu extensions.
  bulkDeleteContextMenuExtensions(input: BulkDeleteContextMenuExtensions): ContextMenuExtensionList

  # Update an organization
  updateOrganization(
    # Fields required to update an organization.
    input: UpdateOrganization!
  ): Organization
  addToEngineWhitelist(toAdd: SetEngineWhitelist!): EngineWhitelist
  addToEngineBlacklist(toAdd: SetEngineBlacklist!): EngineBlacklist
  deleteFromEngineBlacklist(toDelete: SetEngineBlacklist!): EngineBlacklist
  deleteFromEngineWhitelist(toDelete: SetEngineBlacklist!): EngineWhitelist

  # Create an entity identifier type, such as "face" or "image".
  # Entity identifier types are typically created or modified
  # only by Veritone engineering. Most libraries and
  # entities will use existing entity identifier types.
  createEntityIdentifierType(
    # Fields required to create an entity identifier type.
    input: CreateEntityIdentifierType!
  ): EntityIdentifierType

  # Update an entity identifier type.
  updateEntityIdentifierType(
    # Fields required to update an entity identifier type.
    input: UpdateEntityIdentifierType!
  ): EntityIdentifierType

  # Create a library type, such as "ad" or "people".
  # Entity identifier types are typically created or modified
  # only by Veritone engineering. Most libraries
  # will use existing entity identifier types.
  createLibraryType(
    # Fields needed to create a new library type.
    input: CreateLibraryType!
  ): LibraryType

  # Update a library type.
  updateLibraryType(
    # Fields needed to update a library type.
    input: UpdateLibraryType!
  ): LibraryType

  # Create a new library.
  # Once the library is created, the client can add
  # entities and entity identifiers. Note that the
  # library type determines what types of entity identifiers
  # can be used within the library.
  createLibrary(
    # Fields needed to create a new library.
    input: CreateLibrary!
  ): Library

  # Update an existing library.
  updateLibrary(
    # Fields needed to update a library
    input: UpdateLibrary!
  ): Library

  # Delete a library. This mutation will also delete all entities,
  # entity identifiers, library engine models, and associated objects.
  deleteLibrary(
    # Provide the ID of the library to delete.
    id: ID!
  ): DeletePayload

  # Publish a new version of a library.
  # Increments library version by one and trains compatible engines.
  publishLibrary(
    # ID of the library to publish
    id: ID!
  ): Library

  # Create a new entity.
  createEntity(
    # Fields required to create a new entity.
    input: CreateEntity!
  ): Entity

  # Update an entity.
  updateEntity(
    # Fields required to update an entity.
    input: UpdateEntity!
  ): Entity

  # Delete an entity. This mutation will also delete all associated
  # entity identifiers and associated objects.
  deleteEntity(
    # Supply the ID of the entity to delete.
    id: ID!
  ): DeletePayload

  # Create an entity identifier.
  # This mutation accepts file uploads. To use this mutation and upload a file,
  # send a multipart form POST containing two parameters:  `query`, with the
  # GraphQL query, and `file` containing the file itself.
  # For more information see the documentation at https://veritone-developer.atlassian.net/wiki/spaces/DOC/pages/13893791/GraphQL.
  createEntityIdentifier(
    # Fields needed to create an entity identifier.
    input: CreateEntityIdentifier!
  ): EntityIdentifier
  updateEntityIdentifier(
    # Fields required to update an entity identifier.
    input: UpdateEntityIdentifier!
  ): EntityIdentifier

  # Delete an entity identifier
  deleteEntityIdentifier(
    # Supply the ID of the entity identifier to delete.
    id: ID!
  ): DeletePayload

  # Create a library engine model.
  createLibraryEngineModel(
    # Fields required to create a library engine model.
    input: CreateLibraryEngineModel!
  ): LibraryEngineModel

  # Update a library engine model
  updateLibraryEngineModel(
    # Fields required to update a library engine model
    input: UpdateLibraryEngineModel!
  ): LibraryEngineModel

  # Delete a library engine model
  deleteLibraryEngineModel(
    # Supply the ID of the library engine model to delete.
    id: ID!
  ): DeletePayload

  # Create Dataset Library Configuration
  createLibraryConfiguration(
    # Fields required to create library configuration
    input: CreateLibraryConfiguration!
  ): LibraryConfiguration

  # Update Dataset Library Configuration
  updateLibraryConfiguration(
    # Fields required to create library configuration
    input: UpdateLibraryConfiguration!
  ): LibraryConfiguration

  # Delete Dataset Library Configuration
  deleteLibraryConfiguration(
    # Supply configuration ID to delete.
    id: ID!
  ): DeletePayload

  # Add recordings to a dataset library
  addLibraryDataset(input: AddLibraryDataset!): LibraryDataset

  # Remove recordings from a dataset library
  deleteLibraryDataset(input: DeleteLibraryDataset!): DeleteLibraryDatasetPayload

  # Apply an application workflow step, such as "submit" or "approve"
  applicationWorkflow(
    # Fields required to apply a application workflow step
    input: ApplicationWorkflow
  ): Application

  # Apply an application workflow step, such as "submit" or "approve"
  engineWorkflow(
    # Fields required to apply a engine workflow step
    input: EngineWorkflow
  ): Engine

  # Creates a widget associated with a collection
  createWidget(
    # Fields needed to create a new widget
    input: CreateWidget
  ): Widget

  # Updates a widget
  updateWidget(
    # Fields needed to update a widget
    input: UpdateWidget
  ): Widget

  # Create a new user within an organization.
  createUser(
    # Fields needed to create a user.
    input: CreateUser
  ): User

  # Create a new organization.
  createOrganization(
    # Fields needed to create an organization.
    input: CreateOrganization!
  ): Organization

  # Update an existing user
  updateUser(
    # Fields needed to update a user
    input: UpdateUser
  ): User

  # Force a user to update password on next login.
  # This mutation is used by administrators.
  createPasswordUpdateRequest(
    # Fields needed to create a password update request
    input: CreatePasswordUpdateRequest
  ): User

  # Get password token info for current user
  getCurrentUserPasswordToken(input: GetCurrentUserPasswordToken!): PasswordTokenInfo!

  # Create a password reset request. This mutation is used on behalf
  # of a user who needs to reset their password. It operates only on
  # the currently authenicated user (based on the authentication token provided).
  createPasswordResetRequest(input: CreatePasswordResetRequest): CreatePasswordResetRequestPayload

  # Update the current authenticated user
  updateCurrentUser(input: UpdateCurrentUser!): User!

  # Change the current authenticated user's password
  changePassword(
    # Fields needed to change password
    input: ChangePassword!
  ): User

  # Delete a user
  deleteUser(
    # Supply the ID of the user to delete.
    id: ID!
  ): DeletePayload

  # Create a structured data registry schema metadata.
  createDataRegistry(input: CreateDataRegistry!): DataRegistry

  # Update a structured data registry schema metadata.
  updateDataRegistry(input: UpdateDataRegistry!): DataRegistry

  # Update a structured data registry schema.
  upsertSchemaDraft(input: UpsertSchemaDraft!): Schema
  updateSchemaState(input: UpdateSchemaState!): Schema

  # Create (ingest) a structured data object
  createStructuredData(input: CreateStructuredData!): StructuredData

  # Delete a structured data object
  deleteStructuredData(input: DeleteStructuredData!): DeletePayload

  # Create (ingest) a structured data object
  createCollection(
    # Fields required to create new collection
    input: CreateCollection
  ): Collection

  # Update a collection
  updateCollection(
    # Fields needed to update a collection
    input: UpdateCollection
  ): Collection

  # Delete Collection
  deleteCollection(
    folderId: ID

    # Supply the ID of the folder or collection to delete
    id: ID
  ): DeletePayload

  # Share a collection, allowing other organizations to view the data
  # it contains.
  shareCollection(
    # Fields needed to share a collection
    input: ShareCollection
  ): Share
  updateSharedCollectionMentions(
    # ID of the shared collection to update
    shareId: String!

    # List of mentionIds to add or remove
    mentionIds: [ID!]

    # Indicates whether or not the mentions are to be added or deleted
    type: SharedCollectionUpdateType!
  ): Share
  updateSharedCollectionHistory(input: UpdateSharedCollectionHistory): SharedCollectionHistory

  # Share a mention from a collection
  shareMentionFromCollection(
    # Fields needed to share a mention
    input: ShareMentionFromCollection
  ): Share

  # Share mention
  shareMention(input: ShareMention): Share

  # Share mentions in bulk
  shareMentionInBulk(input: ShareMentionInBulk): [Share]

  # Add a mention to a collection
  createCollectionMention(
    # Fields needed to add a mention to a collection
    input: CollectionMentionInput
  ): CollectionMention
  createCollectionMentions(
    # Fields needed to add mentions to a collection
    input: CreateCollectionMentions
  ): [CollectionMention!]!

  # Update a mention in a collection
  updateCollectionMention(
    # Fields needed to add mentions to a collection
    input: UpdateCollectionMention!
  ): CollectionMention!

  # Remove a mention from a collection
  deleteCollectionMention(
    # Fields needed to delete a mention from a collection
    input: CollectionMentionInput
  ): CollectionMention

  # Create a new folder
  createFolder(
    # Fields needed to create a new folder.
    input: CreateFolder
  ): Folder

  # Update an existing folder
  updateFolder(
    # Fields needed to update a folder.
    input: UpdateFolder
  ): Folder

  # Move a folder from one parent folder to another.
  moveFolder(
    # Fields needed to move a folder
    input: MoveFolder
  ): Folder

  # Delete a folder
  deleteFolder(
    # Fields needed to delete a folder
    input: DeleteFolder
  ): DeletePayload

  # Create a mention comment
  createMentionComment(
    # Fields needed to create a mention comment
    input: CreateMentionComment
  ): MentionComment

  # Update a mention comment
  updateMentionComment(
    # Fields needed to update a mention comment
    input: UpdateMentionComment
  ): MentionComment

  # Delete a mention comment
  deleteMentionComment(
    # Fields needed to delete a mention comment
    input: DeleteMentionComment
  ): DeletePayload

  # Create a mention rating
  createMentionRating(
    # Fields needed to create a mention rating
    input: CreateMentionRating
  ): MentionRating

  # Update a mention rating
  updateMentionRating(
    # Fields needed to update a mention rating
    input: UpdateMentionRating
  ): MentionRating

  # Delete a mention rating
  deleteMentionRating(
    # Fields needed to delete a mention rating.
    input: DeleteMentionRating
  ): DeletePayload

  # Login as a user. This mutation does not require an existing authentication
  # context (via `Authorization` header with bearer token, cookie, etc.).
  # Instead, the client supplies credentials to this mutation, which then
  # authenticates the user and sets up the authentication context.
  # The returned tokens can be used to authenticate future requests.
  userLogin(
    # Fields needed to log in
    input: UserLogin
  ): LoginInfo

  # Logout user and invalidate user token
  userLogout(
    # User token that should be invalidated
    token: String!
  ): Boolean

  # Refresh a user token, returning a fresh token so that the client
  # can continue to authenticate to the API.
  refreshToken(token: String!): LoginInfo

  # Validate a user token. This mutation is used by services to determine
  # if the token provided by a given client is valid.
  validateToken(token: String!): LoginInfo

  # Create a mention object
  createMention(input: CreateMention!): Mention

  # Update a mention object
  updateMention(input: UpdateMention!): Mention

  # Update a set of mentions
  updateMentions(input: UpdateMentions!): [Mention]

  # Create root folder for an organization
  createRootFolders(
    # The type of root folder to create
    rootFolderType: RootFolderType = watchlist
  ): [Folder]

  # Apply bulk updates to watchlists.
  # This mutation is currently available only to Veritone operations.
  bulkUpdateWatchlist(
    # A filter indicating which watchlists should be updated.
    # At least one filter condition must be provided.
    # Only watchlists for the user's organization will be updated.
    filter: BulkUpdateWatchlistFilter!

    # Fields used to update a watchlist.
    input: BulkUpdateWatchlist
  ): WatchlistList

  # File a TemporalDataObject in a folder. A given TemporalDataObject can
  # be filed in any number of folders, or none. Filing causes the TemporalDataObject
  # and its assets to be visible within the folder.
  fileTemporalDataObject(
    # The fields needed to file a TemporalDataObject in a folder
    input: FileTemporalDataObject!
  ): TemporalDataObject

  # Unfile a TemporalDataObject from a folder. This causes the TemporalDataObject
  # and its assets to disappear from the folder, but does not otherwise affect
  # either the TDO or the folder and does not change access controls.
  unfileTemporalDataObject(
    # The fields needed to file a TemporalDataObject in a folder
    input: UnfileTemporalDataObject!
  ): TemporalDataObject

  # Moves a TemporalDataObject from one parent folder to another.
  # Any other folders the TemporalDataObject is filed in are unaffected.
  moveTemporalDataObject(
    # Fields need to move a TemporalDataObject
    input: MoveTemporalDataObject!
  ): TemporalDataObject

  # Upload and store an engine result. The result will be stored as an
  # asset associated with the target TemporalDataObject and the
  # task will be updated accordingly.
  # Use a multipart form POST to all this mutation.
  uploadEngineResult(
    # Fields needed to upload and store an engine result
    input: UploadEngineResult!
  ): Asset
  createWatchlist(input: CreateWatchlist!): Watchlist
  updateWatchlist(input: UpdateWatchlist!): Watchlist
  deleteWatchlist(id: ID!): DeletePayload
  updateCognitiveSearch(input: UpdateCognitiveSearch): CognitiveSearch
  createCognitiveSearch(input: CreateCognitiveSearch): CognitiveSearch
  deleteCognitiveSearch(id: ID!): DeletePayload
  fileWatchlist(input: FileWatchlist!): Watchlist
  unfileWatchlist(input: UnfileWatchlist!): Watchlist

  # Share a folder with other organizations
  shareFolder(input: ShareFolderInput): Folder

  # Create a TDO and an asset with a single call
  createTDOWithAsset(
    # Input fields necessary to create the TDO and asset
    input: CreateTDOWithAsset
  ): TemporalDataObject
  createSubscription(input: CreateSubscription!): Subscription
  updateSubscription(input: UpdateSubscription!): Subscription
  deleteSubscription(id: ID!): DeletePayload

  # Create trigger for events or types.
  createTriggers(input: CreateTriggers!): [Trigger]

  # Delete a registed trigger by ID.
  deleteTrigger(id: ID!): DeletePayload

  # Validates if an engine output conforms to the engine output guidelines
  validateEngineOutput(input: JSON!): Boolean!

  # JWT tokens with a more limited scoped token to specific
  # resources to the recording, task, and job
  # and also has no organization association.
  getEngineJWT(input: getEngineJWT!): JWTTokenInfo!

  # Verify JWT token
  verifyJWT(jwtToken: String!): VerifyJWTPayload

  # Create a new Saved Search
  createSavedSearch(input: CreateSavedSearch!): SavedSearch!

  # Delete a saved search
  deleteSavedSearch(id: ID!): DeletePayload!

  # Mark existing saved search profile as deleted
  # Create new saved search profile
  replaceSavedSearch(input: ReplaceSavedSearch!): SavedSearch!

  # Send a basic email. Mutation returns true for a success message.
  sendEmail(input: SendEmail!): Boolean!

  # Create new content template into a folder
  createFolderContentTempate(input: CreateFolderContentTempate!): FolderContentTemplate!

  # Update existing content template by folderContentTemplateId
  updateFolderContentTempate(input: UpdateFolderContentTempate!): FolderContentTemplate!

  # Delete existing folder content template by folderContentTemplateId
  deleteFolderContentTempate(
    # Folder Content Template Id
    id: ID!
  ): DeletePayload!

  # Create an export request. The requested TDO data, possibly including
  # TDO media and engine results, will be exported offline.
  createExportRequest(
    # Input data required to create the export request
    input: CreateExportRequest!
  ): ExportRequest!

  # Update an export request
  updateExportRequest(
    # Input data required to update an export request
    input: UpdateExportRequest!
  ): ExportRequest!

  # Create Mention in bulk. The input should be an array of createMentions
  createMentions(input: CreateMentions!): MentionList

  # Create Media Share. Returning the url of the share
  createMediaShare(input: CreateMediaShare!): CreatedMediaShare!

  # Create or Update Workflow data.
  setWorkflowRuntimeStorageData(workflowRuntimeId: ID!, input: CreateWorkflowRuntimeStorageData!): WorkflowRuntimeStorageData!

  # Create a new event
  createEvent(input: CreateEvent!): Event!

  # Update an event
  updateEvent(input: UpdateEvent!): Event!

  # Subscribe to an event
  subscribeEvent(input: SubscribeEvent!): ID!

  # Unsubscribe to an event
  unsubscribeEvent(id: ID!): UnsubscribeEvent!

  # Emit an event
  emitEvent(input: EmitEvent!): EmitEventResponse!

  # Create a new event trigger template
  createEventActionTemplate(input: CreateEventActionTemplate!): EventActionTemplate!

  # Update an event trigger template
  updateEventActionTemplate(input: UpdateEventActionTemplate!): EventActionTemplate!

  # Start a Veritone Workflow instance
  startWorkflowRuntime(workflowRuntimeId: ID!, orgId: ID!, generateAuthToken: Boolean = false): WorkflowRuntimeResponse!

  # Shutdown Veritone Workflow instance
  stopWorkflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!

  # Create a processTemplate in CMS
  createProcessTemplate(input: CreateProcessTemplate!): ProcessTemplate!

  # Update a processTemplate by ID in CMS
  updateProcessTemplate(input: UpdateProcessTemplate!): ProcessTemplate!

  # Delete a processTemplate by ID in CMS
  deleteProcessTemplate(id: ID!): DeletePayload!

  # Create a mention export request. The requested mentionFilters including
  # The mention export file csv will be exported offline.
  createMentionExportRequest(
    # Input data required to create the export request
    input: CreateMentionExportRequest!
  ): ExportRequest!

  # Update status or assetURI of a mentionExportRequest
  # Often use when the file export was completed or downloaded
  updateMentionExportRequest(input: UpdateMentionExportRequest!): ExportRequest!

  # Create a creative
  createCreative(input: CreateCreative!): Creative!

  # Update a creative
  updateCreative(input: UpdateCreative!): Creative!

  # Delete a creative
  deleteCreative(id: ID!): DeletePayload!

  # Emit a system-level emit. This mutation is used only by
  # Veritone platform components.
  emitSystemEvent(
    # Data required to create the event
    input: EmitSystemEvent!
  ): SystemEventInfo!

  # Creates an immutable audit log event with the given payload
  emitAuditEvent(input: EmitAuditEvent!): AuditEvent!
  createContextMenuExtension(input: CreateContextMenuExtension!): ContextMenuExtension!
  updateContextMenuExtension(input: UpdateContextMenuExtension!): ContextMenuExtension!
  deleteContextMenuExtension(input: DeleteContextMenuExtension!): DeletePayload!

  # Add or update an organization integration config by
  # organization id and integration id
  setOrganizationIntegrationConfig(input: SetOrganizationIntegrationConfig!): IntegrationConfig!

  # Delete an integration config
  deleteOrganizationIntegrationConfig(input: DeleteOrganizationIntegrationConfig!): DeleteIntegrationConfigPayload!
  updateUserStatus(
    # Data required to create the event
    input: UpdateUserStatus!
  ): User!
  createBenchmark(input: CreateBenchmark): BenchmarkJob
  createCluster(input: CreateCluster!): Cluster
  updateCluster(input: UpdateCluster!): Cluster
  deleteCluster(id: ID!): DeletePayload
  pauseCluster(input: PauseCluster!): Cluster
  unpauseCluster(input: UnpauseCluster!): Cluster
  createClusterNode(input: CreateClusterNode!): ClusterNode
  updateClusterNode(input: UpdateClusterNode!): ClusterNode
  deleteClusterNode(id: ID!): DeletePayload
  createScheduledJob(input: CreateScheduledJob!): ScheduledJob!
  cloneScheduledJob(input: CloneScheduledJob!): ScheduledJob!
  revertScheduledJob(input: RevertScheduledJob!): ScheduledJob!
  updateScheduledJob(input: UpdateScheduledJob!): ScheduledJob!
  deleteScheduledJob(id: ID!): DeletePayload

  # Create a new content template on a scheduled job
  createScheduledJobContentTemplate(input: CreateScheduledJobContentTemplate!): ScheduledJobContentTemplate!
  deleteScheduledJobContentTemplate(
    # ID of the scheduled job content template to delete. It will be removed from the
    # scheduled job. The underlying SDO will not be deleted.
    id: ID!
  ): DeletePayload

  # Create a new source
  createSource(input: CreateSource!): Source
  updateSource(input: UpdateSource!): Source
  deleteSource(id: ID!): DeletePayload

  # Create a new source content template on a source
  createSourceContentTemplate(input: CreateSourceContentTemplate!): SourceContentTemplate!
  deleteSourceContentTemplate(
    # ID of the source content template to delete. It will be removed from the
    # source. The underlying SDO will not be deleted.
    id: ID!
  ): DeletePayload
  createSourceType(input: CreateSourceType!): SourceType
  updateSourceType(input: UpdateSourceType!): SourceType
  deleteSourceType(id: ID!): DeletePayload
  createJobPipeline(input: CreateJobPipeline!): JobPipeline!
  updateJobPipeline(input: UpdateJobPipeline!): JobPipeline!
  deleteJobPipeline(id: ID!): DeletePayload
  createJobTemplate(input: CreateJobTemplate!): JobTemplate!
  updateJobTemplate(input: UpdateJobTemplate!): JobTemplate!
  deleteJobTemplate(id: ID!): DeletePayload
  createTaskTemplate(input: CreateTaskTemplate!): TaskTemplate!
  updateTaskTemplate(input: UpdateTaskTemplate!): TaskTemplate!
  deleteTaskTemplate(id: ID!): DeletePayload
  createNextPipelineJobs(input: CreateNextPipelineJobs!): [Job]

  # Creates one or more jobs based on the supplied scheduled job.
  launchScheduledJobs(input: LaunchScheduledJobs!): [Job]

  # Creates one or more jobs based on the supplied job templates.
  launchJobTemplates(input: LaunchJobTemplates!): [Job]

  # Get next bundle for cluster.
  getNextBundleForCluster(input: GetNextBundleForCluster!): Bundle!

  # Update bundle status as cluster.
  updateBundleStatusAsCluster(input: updateBundleStatusAsCluster): Bundle!

  # Pause for a node
  pauseClusterNode(input: PauseClusterNode!): ClusterNode

  # Unpause for a node
  unpauseClusterNode(input: UnpauseClusterNode!): ClusterNode

  # Update the cluster's runtime state. Used only by infrastructure elements.
  updateClusterState(input: UpdateClusterState!): Cluster
}

enum OrderDirection {
  asc
  desc
}

type Organization {
  # The organization ID
  id: ID!

  # The organization's name
  name: String

  # A list of types applied to the organization, such
  # as `Broadcaster` or `Agency`.
  type: [String]

  # Applications belonging to the organization
  applications(offset: Int = 0, limit: Int = 30): ApplicationList

  # Freeform metadata in JSON format
  jsondata: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  seatLimit: Int

  # Organization's current status
  status: OrganizationStatus

  # Roles allowed within the organization
  roles: [Role]

  # Users belonging to the organization
  users(offset: Int = 0, limit: Int = 30): UserList

  # List of engines forbidden to this organization.
  blacklist: EngineBlacklist

  # List of engines allowed for this organization.
  # Takes precedence of the blacklist. That is, if a whitelist
  # is defined, then only engines in the whitelist are permitted
  # regardless of what is in the blacklist.
  # This field is not fully implemented!
  whitelist: EngineWhitelist

  # Custom schemas defined by this organization.
  # This field is not fully implemented!
  schemas: SchemaList

  # Watchlists for this organization.
  # This field is not fully implemented!
  watchlists: WatchlistList

  # Collections for this organization
  collections(
    # Provide a name to filter by collection name
    name: String

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): CollectionList

  # Folder tree for this organization
  rootFolder(
    # Specify a root folder type to retrieve a specific root folder
    type: RootFolderType = watchlist
  ): Folder

  # Business unit
  businessUnit: String

  # Dashboards
  dashboards: [Dashboard]
  imageUrl: String

  # An ID corresponding to the organization used internally for some
  # provisioning elements. `applicationId` on `TemporalDataObject`, `Job`,
  # and some other types uses this value instead of the organization `id`.
  internalApplicationId: ID

  # The number of active seats
  seats: Int

  # The amount of media uploaded by this org in milliseconds
  mediaUsageMs: Int

  # Retrieve integration config of organization by integration id
  integrationConfig(id: ID!): IntegrationConfig
}

type OrganizationList implements Page {
  records: [Organization]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum OrganizationStatus {
  active
  deleted
}

enum OrganizationType {
  agency
  broadcaster
}

# Common fields used by queries and fields that support paging to represent
# a single page of results.
interface Page {
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type PasswordTokenInfo {
  passwordToken: String
}

input PauseCluster {
  id: ID!
}

input PauseClusterNode {
  # Node ID
  id: ID!
}

type Permission {
  id: ID!
  name: String
  description: String
}

type PermissionList implements Page {
  records: [Permission]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

input PollTask {
  id: ID!
  jobId: ID!
  pollPayload: JSON
}

type ProcessTemplate {
  id: ID!
  organizationId: ID!
  name: String!
  taskList: JSON!
}

type ProcessTemplateList implements Page {
  records: [ProcessTemplate!]
  offset: Int!
  limit: Int!
  count: Int
}

# Metadata that represents a program.
type Program implements Metadata {
  id: ID
  name: String!
  image: String
  liveImage: String
}

type ProgramAffiliate {
  sourceId: ID!
  source: Source
  scheduledJobId: ID!
  scheduledJob: ScheduledJob
  scheduledDay: DayOfWeek

  # The day of week adjusted to source live timezone
  scheduledDayLocal: DayOfWeek
  startDateTime: DateTime
  stopDateTime: DateTime
  startTime: Time
  stopTime: Time
  status: String
}

type ProgramAffiliateList implements Page {
  records: [ProgramAffiliate!]
  offset: Int!
  limit: Int!
  count: Int
}

# A property is a name-value pair. This is the base interface for properties.
interface Property {
  name: String!
}

# Queries are used to retrieve data. If you're new to our API,
# try the `me` query to explore the information you have access to.
# Hit `ctrl-space` at any time to activate field completion hints, and
# mouse over a field or parameter to see its documentation.
type Query {
  # Retrieve a list of temporal data objects.
  temporalDataObjects(
    # Organization ID to get TDOs for. Defaults to the user's own organization.
    # You can only retrieves content for your own organizations or organizations
    # that have shared data with yours.
    organizationId: ID

    # Application ID (an authorization construct that maps directly to organization ID)
    # to get TDOs for. Defaults to the user's own organization.
    applicationId: ID

    # Provide an ID to retrieve a single specific TDO.
    id: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Optionally, specify a source ID. TDOs ingested from this source will
    # be returned.
    sourceId: ID

    # Optionally, specify a scheduled job ID. TDOs ingested under this
    # scheduled job will be returned.
    scheduledJobId: ID

    # Whether to retrieve only tdos with the specified sampleMedia value
    sampleMedia: Boolean = false

    # Whether to retrieve public data that is not part of the user's organization.
    # The default is false. Pass true to include public data in the result set.
    includePublic: Boolean = false
    orderBy: TemporalDataObjectOrderBy = startDateTime
    orderDirection: OrderDirection = desc

    # Provide optional filters against any date/time field to filter
    # objects within a given time window.
    # Matching objects must meet all of the given conditions.
    dateTimeFilter: [TemporalDataObjectDateTimeFilter!]

    # Retrieve TDOs associated with the given mention
    mentionId: ID
  ): TDOList

  # Retrieve a single temporal data object
  temporalDataObject(
    # the TDO ID
    id: ID!
  ): TemporalDataObject

  # Retrieve a single Asset
  asset(
    # The asset ID
    id: ID!
  ): Asset

  # Retrieve a single Widget
  widget(
    # The widget ID
    id: ID!
  ): Widget

  # Retrieve clone job entries
  cloneRequests(
    # Provide an ID to retrieve a single specific clone request.
    id: ID

    # Application ID to get clone requests for. Defaults to the user's own application.
    applicationId: ID
    offset: Int = 0
    limit: Int = 30
  ): CloneRequestList

  # Retrieve engines
  engines(
    # Provide an ID to retrieve a single specific engine.
    id: ID
    ids: [ID!]

    # Provide a category ID to filter by engine category.
    categoryId: String

    # provide a category name or ID to filter by engine category
    category: String

    # Provide a list of states to filter by engine state.
    state: [EngineState]

    # If true, return only engines owned by the user's organization.
    owned: Boolean = false

    # If true, return only engines that require a library.
    libraryRequired: Boolean

    # If true, return only engines that create their own TDO.
    # If false, return only engines that do not create a TDO.
    # If not set, return either.
    createsTDO: Boolean

    # Provide a name, or part of a name, to search by engine name
    name: String

    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30

    # Filters for engine attributes
    filter: EngineFilter

    # Provide a list of EngineSortField to sort by.
    orderBy: [EngineSortField]
  ): EngineList

  # Retrieve a single engine by ID
  engine(
    # Provide the engine ID
    id: ID!
  ): Engine
  engineBuild(
    # Provide the build ID
    id: ID!
  ): Build

  # Retrieve engine categories
  engineCategories(
    # Provide an ID to retrieve a single specific engine category.
    id: ID

    # Provide multiple IDs to retrieve engine categories
    ids: [ID!]

    # Provide a name, or part of one, to search by category name
    name: String

    # Return all categories of an engine type
    type: String

    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30
  ): EngineCategoryList

  # Retrieve a specific engine category
  engineCategory(
    # Supply the ID of the engine category to retrieve
    id: ID!
  ): EngineCategory

  # Retrieve jobs
  jobs(
    hasTargetTDO: Boolean

    # Provide an ID to retrieve a single specific job.
    id: ID

    # Provide a list of status strings to filter by status
    status: [JobStatusFilter!]
    applicationStatus: String

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify the maximum number of results to included in this response, or page size.
    limit: Int = 30

    # Provide an application ID to filter jobs for a given application.
    # Defaults to the user's own application.
    applicationId: ID

    # Provide a target ID to get the set of jobs running against a particular TDO.
    targetId: ID

    # Provide a cluster ID to get the jobs running on a specific cluster
    clusterId: ID

    # Provide a list of scheduled job IDs to get jobs associated with the scheduled jobs
    scheduledJobIds: [ID!]

    # Return only jobs that are (true) or are not (false) associated with a scheduled job
    hasScheduledJobId: Boolean

    # Provide sort information. The default is to sort by
    # createdDateTime descending.
    orderBy: [JobSortField!]

    # Filter by date/time field
    dateTimeFilter: [JobDateTimeFilter!]

    # Provide list of application IDs to filter jobs.
    # Defaults to the user's own application.
    applicationIds: [ID]

    # Provide a list of engine IDs to filter for jobs
    # that contain tasks for the specified engines.
    engineIds: [ID!]

    # Provide a list of engine category IDs to filter for jobs
    # that contain tasks for engines in the specific categories.
    engineCategoryIds: [ID!]
  ): JobList

  # Retrieve a single job
  job(
    # the job ID
    id: ID!
  ): Job

  # Retrieve a single task by ID
  task(
    # Provide the task ID.
    id: ID!
  ): Task

  # Retrieve entity identifier types
  entityIdentifierTypes(
    # Provide an ID to retrieve a single specific entity identifier type.
    id: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): EntityIdentifierTypeList
  entityIdentifierType(
    # Provide the entity identifier type ID
    id: ID!
  ): EntityIdentifierType

  # Retrieve all library types
  libraryTypes(
    # Provide an ID to retrieve a single specific library type.
    id: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): LibraryTypeList

  # Retrieve a single library type
  libraryType(
    # Provide an ID to retrieve a single specific library type.
    id: ID
  ): LibraryType

  # Retrieve libraries and entities
  libraries(
    # Provide an ID to retrieve a single specific library.
    id: ID

    # Provide a name string to search by name.
    name: String

    # Provide the name or ID of a library to search for libraries
    # that contain that type.
    type: String

    # Provide the id of an entity identifier type to search for libraries that correlate
    # to that type.
    entityIdentifierTypeIds: [String!]

    # Specify true if only libraries owned by the user's organization
    # should be returned. Otherwise, shared libraries will be included.
    includeOwnedOnly: Boolean = false

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Specify a field to order by
    orderBy: LibraryOrderBy

    # Specify the direction to order by
    orderDirection: OrderDirection
  ): LibraryList

  # Retrieve a specific library
  library(
    # Provide a library ID.
    id: ID!
  ): Library

  # Retrieve a specific library engine model
  libraryEngineModel(
    # Provide the library engine model ID
    id: ID!
  ): LibraryEngineModel

  # Retrieve a specific entity
  entity(
    # Provide an entity ID.
    id: ID!
  ): Entity

  # Retrieve a list of entities across libraries
  entities(
    # Provide a list of entity IDs to retrieve those entities
    ids: [ID!]

    # Provide a list of library IDs to retrieve entities across
    # multiple libraries.
    libraryIds: [ID!]
    isPublished: Boolean
    identifierTypeId: ID
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: LibraryEntityOrderBy
    orderDirection: OrderDirection
  ): EntityList

  # Retrieve library configuration
  libraryConfiguration(
    # Provide configuration id
    id: ID!
  ): LibraryConfiguration

  # Retrieve applications. These are custom applications integrated into
  # the Veritone platform using the VDA framework.
  applications(
    # Provide an ID to retrieve a single specific application.
    id: ID

    # Provide a status, such as "draft" or "active"
    status: ApplicationStatus

    # If true, return only applications owned by the user's organization.
    owned: Boolean

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): ApplicationList

  # Retrieve organizations
  organizations(
    # Provide an ID to retrieve a single specific organization.
    id: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Provide a property from the organization kvp to filter the organization list.
    kvpProperty: String

    # Provide value to for the kvpFeature filter.
    # If not present the filter becomes kvpProperty existence filter
    kvpValue: String

    # Optionally, supply a string for string match
    name: String

    # Supply the type of string match to apply.
    nameMatch: StringMatch = startsWith
  ): OrganizationList

  # Retrieve a single organization
  organization(
    # The organization ID
    # TODO take application ID as well as org ID
    id: ID!
  ): Organization

  # Retrieve permissions
  permissions(
    # Provide an ID to retrieve a single specific permission.
    id: ID
    name: String

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): PermissionList

  # Retrieve users
  users(
    # Provide an ID to retrieve a single specific user.
    # A user ID is a string in UUID format.
    id: ID

    # Provide IDs to retrieve multiple users by ID.
    ids: [ID]

    # Provide a name, or part of one, to search by name.
    name: String

    # Provide a list of organization IDs to filter your search by organization.
    organizationIds: [ID]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Include all organization users.
    includeAllOrgUsers: Boolean

    # Filter by date/time field
    dateTimeFilter: [UsersDateTimeFilter!]

    # Filter by account status
    status: UserStatus
  ): UserList

  # Retrieve an individual user
  user(
    # The user ID.
    # A user ID is a string in UUID format.
    id: ID!
    organizationIds: [ID]
  ): User

  # Retrieve user's organization API tokens
  tokens: [Token]

  # Retrieve information for the current logged-in user
  me: User

  # Retrieve groups
  groups(
    # Provide an ID to retrieve a specific group by ID
    id: ID

    # Provide IDs to retrieve multiple groups by ID
    ids: [ID]

    # Provide a name, or part of one, to search for groups by name
    name: String

    # Provide a list of organization IDs to retrieve groups defined
    # within certain organizations.
    organizationIds: [ID]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): GroupList

  # Retrieve a single mention
  mention(
    # The mention ID
    mentionId: ID!

    # Comments pagination - limit
    limit: Int = 25

    # Comments pagination - limit
    offset: Int = 0

    # The user who owns the mention.
    userId: String
  ): Mention

  # Retrieve a shared mention
  sharedMention(
    # share token
    shareId: ID!
  ): SharedMention

  # Search for mentions across an index.
  # This query requires a user token.
  searchMentions(
    # JSON structure containing the search query.
    # See https://docs.veritone.com/#/apis/search-quickstart for full details on the search query syntax
    search: JSON!
  ): SearchResult

  # Search for media across an index.
  # This query requires a user token.
  searchMedia(
    # JSON structure containing the search query.
    # See https://docs.veritone.com/#/apis/search-quickstart for full details on the search query syntax
    search: JSON!
  ): SearchResult

  # Retrieve the root folders for an organization
  rootFolders(
    # The type of root folder to retrieve
    type: RootFolderType
  ): [Folder]

  # Retrieve a single folder. Used to navigate the folder tree structure.
  folder(
    # Provide an ID to retrieve a single specific user.
    id: ID!
  ): Folder
  auditEvents(
    # An elastic query for audit events
    query: JSON
    orderDirection: OrderDirection = desc

    # Filter logs by a specific application
    application: String

    # Term filters to filter documents by properties in the payload
    terms: [JSON!]
    limit: Int = 30
    offset: Int = 0
  ): AuditEventList!
  folderOverview(
    # Tree Object Ids
    ids: [ID!]!
    rootFolderType: RootFolderType = watchlist
  ): FolderOverview
  folderSummaryDetails(
    # Tree Object Ids
    ids: [ID!]!
    rootFolderType: RootFolderType = watchlist
  ): [FolderSummaryDetail]

  # Retrieve a single application
  application(
    # The application ID
    id: ID!
  ): Application

  # Retrieve a list of schemas for structured data ingestions
  schemas(
    # Id of a schema to retrieve
    id: ID

    # Ids of schemas to retrieve
    ids: [ID!]

    # Specify the id of the DataRegistry to get schemas
    dataRegistryId: ID

    # Specify one or more statuses to filter by schema status
    status: [SchemaStatus!]

    # Specify a major version to filter schemas
    majorVersion: Int

    # Specify a data registry name to filter schemas
    name: String

    # The strategy used to find data registry name
    nameMatch: StringMatch = startsWith

    # Limit
    limit: Int = 30

    # Offset
    offset: Int = 0

    # Specify one or more fields and direction to order results
    orderBy: [SchemaOrder]
  ): SchemaList
  schema(id: ID!): Schema
  schemaProperties(
    dataRegistryVersion: [DataRegistryVersion!]
    search: String

    # Limit
    limit: Int = 30

    # Offset
    offset: Int = 0
  ): SchemaPropertyList

  # Retrieve a structured data object
  structuredData(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID!

    # Schema Id for the structured data object to retrieve
    schemaId: ID!
  ): StructuredData

  # Retrieve a structured data object
  structuredDataObject(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID!

    # Schema Id for the structured data object to retrieve
    schemaId: ID!
  ): StructuredData

  # Retrieve a paginated list of structured data object
  structuredDataObjects(
    # Supply the ID of the structured data object to retrieve. This will override filters.
    id: ID

    # List of Ids of the structured data objects to retrieve. This will override filters.
    ids: [ID!]

    # Schema Id for the structured data object to retrieve
    schemaId: ID!
    orderBy: [StructuredDataOrderBy!]
    limit: Int = 30
    offset: Int = 0
    owned: Boolean

    # Query to filter SDO. Supports operations such as and, or, eq, gt, lt, etc.
    # TODO link to syntax documentation
    filter: JSON
  ): StructuredDataList

  # Returns information about the GraphQL server, useful
  # for diagnostics. This data is primarily used by Veritone
  # development, and some fields may be restricted to Veritone administrators.
  graphqlServiceInfo: GraphQLServiceInfo

  # Returns a signed writable S3 URL. A client can then
  # upload to this URL with an HTTP PUT without providing
  # any additional authorization (_note_: it must be a PUT.
  # A POST will fail.)
  getSignedWritableUrl(
    # Optional key of the object to generate a writable
    # URL for. If not provided, a new, unique key will
    # be generated. If a key is provided and resembles a file name
    # (with extension delimited by .), a UUID will be inserted
    # into the file name, leaving the extension intact.
    # If a key is provided and does not resemble
    # a file name, a UUID will be appended.
    key: String

    # Optional type of resource, such as `asset`, `thumbnail`, or `preview`
    type: String

    # Optional extended path information. If the uploaded content will be contained
    # within a container such as a `TemporalDataObject` (for `asset`) or `Library`
    # (for `entityIdentifier`), the ID of the object should be provided here.
    path: String

    # Optional organization ID. Normally this value is computed by the server
    # based on the authorization token used for the request.
    # Is is used only by Veritone platform components.
    organizationId: ID
  ): WritableUrlInfo

  # Return writable storage URLs in bulk.
  # A maximum of 1000 can be created in one call.
  # See `getSignedWritableUrl` for details on usage of the
  # response contents.
  getSignedWritableUrls(
    # Number of signed URLs to return
    number: Int!

    # Optional type of resource, such as `asset`, `thumbnail`, or `preview`
    type: String

    # Optional extended path information. If the uploaded content will be contained
    # within a container such as a `TemporalDataObject` (for `asset`) or `Library`
    # (for `entityIdentifier`), the ID of the object should be provided here.
    path: String

    # Optional organization ID. Normally this value is computed by the server
    # based on the authorization token used for the request.
    # Is is used only by Veritone platform components.
    organizationId: ID
  ): [WritableUrlInfo!]!
  myRights: RightsListing

  # Retrieve the shared folders for an organization
  sharedFolders: [Folder]
  watchlists(
    id: ID
    maxStopDateTime: DateTime
    minStopDateTime: DateTime
    minStartDateTime: DateTime
    maxStartDateTime: DateTime
    name: String
    offset: Int = 0
    limit: Int = 30
    orderBy: WatchlistOrderBy = createdDateTime
    orderDirection: OrderDirection = desc

    # Set `true` to include only disabled watchlist or
    # `false` to include only enabled watchlists. By default,
    # both are included.
    isDisabled: Boolean
  ): WatchlistList
  watchlist(id: ID!): Watchlist
  mentionStatusOptions: [MentionStatus!]!
  dataRegistries(id: ID, ids: [ID!], name: String, nameMatch: StringMatch = startsWith, offset: Int = 0, limit: Int = 30, orderBy: DataRegistryOrderBy = createdDateTime, orderDirection: OrderDirection = desc, filterByOwnership: SchemaOwnership = all): DataRegistryList
  dataRegistry(id: ID!): DataRegistry
  subscription(id: ID!): Subscription!
  cognitiveSearch(id: ID!): CognitiveSearch!
  collections(id: ID, name: String, mentionId: ID, offset: Int = 0, limit: Int = 30): CollectionList!
  collection(id: ID!): Collection!
  collectionMention(folderId: ID!, mentionId: ID!): CollectionMention!

  # Retrieve a list of collection mentions
  # Specify at least one of folderId or mentionId
  collectionMentions(folderId: ID, mentionId: ID, orderBy: CollectionMentionOrderBy, limit: Int = 30, offset: Int = 0): CollectionMentionList!
  mentions(
    id: ID

    # Get mentions created from the specified watchlist
    watchlistId: ID

    # Get mentions associated with the specified source
    sourceId: ID

    # Get mentions associated with sources of the specified source type
    sourceTypeId: ID

    # Get mentions associated directly with the specific TDO
    tdoId: ID

    # Specify date/time filters against mention fields.
    # Querying for mentions can be expensive. If the query does not
    # include a filter by `id`, `tdoId`, `sourceId`, `watchlistId`, or
    # a user-provided `dateTimeFilter`, a default filter of the
    # past 7 days is applied.
    dateTimeFilter: [MentionDateTimeFilter!]

    # Set order information on the query. Multiple fields
    # are supported.
    orderBy: [MentionOrderBy!]
    offset: Int = 0
    limit: Int = 30

    # Provide a folder ID to filter by collection
    folderId: ID
  ): MentionList

  # Retrieves engine results by TDO and engine ID or by job ID.
  engineResults(
    # Provide the ID of the TDO containing engine results to retrieve.
    # If this parameter is used, engineIds or engineCategoryIds must also be set.
    # Results for _only_ the specified TDO will be returned.
    tdoId: ID

    # Provide the ID of the Source containing engine results to retrieve.
    # If this parameter is used, engineIds or engineCategoryIds must also be set.
    # This takes priority over tdoId.
    sourceId: ID

    # Provide one or more engine IDs to retrieve engine results by
    # ID. This parameter is mandatory if tdoId is used, but optional
    # if jobId or engineCategory is used.
    engineIds: [ID!]

    # Provide one or more category IDs to get all results from that categroy.
    engineCategoryIds: [ID!]

    # Provide a job ID to retrieve engine results for the job.
    jobId: ID

    # Provide a mention ID to retrieve engine results for the mention.
    mentionId: ID

    # Start offset ms for the results.
    startOffsetMs: Int

    # End offset ms for the results.
    stopOffsetMs: Int

    # Start date for the results. Takes priority over startOffsetMs.
    startDate: DateTime

    # End date for the results. Takes priority over stopOffsetMs.
    stopDate: DateTime

    # Whether or not to exclude user edited engine results. Defaults to false.
    ignoreUserEdited: Boolean = false

    # A TDO ID can be provided for use if the provided `sourceId` and/or
    # `mentionId` parameters do not resolve to a logical set of TDOs.
    # Depending on parameter settings and available data,
    # results from other TDOs can be included in the response.
    fallbackTdoId: ID
  ): EngineResultList
  trigger(id: ID!): Trigger
  triggers: [Trigger]

  # Fetch all saved searches that the current user has made
  # Fetch all saved searches that have been shared with
  # the current users organization
  # Include any saved searches that the user has created
  savedSearches(offset: Int = 0, limit: Int = 30, includeShared: Boolean = false, filterByName: String, orderBy: SavedSearchOrderBy, orderDirection: OrderDirection): SavedSearchList!

  # Retrieve a list of export requests
  exportRequests(
    # Provide an ID to retrieve a single export request
    id: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Provide a list of status options to filter by status
    status: [ExportRequestStatus!]

    # Provide an event to retrieve export request. Should be 'exportRequest' or 'mentionExportRequest'
    # Default value is 'exportRequest'
    event: ExportRequestEvent = exportRequest
  ): ExportRequestList!
  exportRequest(
    id: ID!

    # Provide an event to retrieve export request. Should be 'exportRequest' or 'mentionExportRequest'
    # Default value is 'exportRequest'
    event: ExportRequestEvent = exportRequest
  ): ExportRequest!

  # Retrieve a event by id
  event(id: ID!): Event!

  # Retrieve a list of events by application
  events(
    # Provide an application to retrieve all its events.
    # Use 'system' to list all public system events.
    application: String!

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): EventList!

  # Retrieve a list of subscriptions by organization
  eventSubscriptions(
    # The event subscription ids
    ids: [ID!]

    # The name of the event
    eventName: String

    # The type of event, such as `mention`, `job`, `engine`.
    eventType: String

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): EventSubscriptionList!
  eventSubscription(id: ID!): EventSubscription!
  eventActionTemplate(id: ID!): EventActionTemplate
  eventActionTemplates(
    # The application id
    ownerApplicationId: ID

    # use "event" for now.  In the future, we allow additional input_type types.  For example, a schedule or a tweet.
    inputType: EventActionTemplateInputType

    # Either "job", "webhook", "sms", "email".  Future action_type could be "gql" where action is purely a function call.
    actionType: EventActionTemplateActionType

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): EventActionTemplateList!

  # This query returns information about time zones recognized by this
  # server. The information is static and does not change.
  timeZones: [TimeZone!]!

  # Examine entries from the audit log. All operations that modify data are
  # written to the audit log. Only entries for the user's own organization
  # can be queried.
  # All queries are bracketed by a time window. A default time window is applied
  # if the `toDateTime` and/or `fromDateTime` parameters are not provided.
  # The maximum time window length is 30 days.
  # Only Veritone and organization administrators can use this query.
  auditLog(
    # Date/time up to which entries will be returned. In other words, the
    # end of the query time window.
    # Defaults to the current time.
    toDateTime: DateTime

    # Date/time from which entries will be returned. In other words, the
    # start of the query time window.
    # Defaults to the `toDateTime` minus 7 days.
    fromDateTime: DateTime

    # Organization ID to query records for. This value can only be used by
    # Veritone administrators. Any value provided by user administrators will
    # be ignored.
    organizationId: ID

    # User name on audit entry. Must be exact match.
    userName: String

    # IP address of the client that generated the audit action. Must be exact match.
    clientIpAddress: String

    # HTTP user agent of the client that generated the audit action. Must be exact match.
    clientUserAgent: String

    # The event type, such as `Create`, `Update`, or `Delete`.
    # Must be exact match.
    eventType: String

    # The ID of the object involved in the audit action. The format of this ID
    # varies by object type. Must be exact match.
    objectId: ID

    # The type of the object involved in the audit action, such as `Watchlist`
    # or `TemporalDataObject`. Must be exact match.
    objectType: String

    # Whether or not the action was successful.
    success: Boolean

    # The unique ID of an audit log entry. Multiple values can be provided.
    id: [ID!]

    # Offset into result set, for paging.
    offset: Int = 0

    # Limit on result size, for paging (page size). Audit queries are
    # lightweight so the default of 100 is higher than the default offset
    # used elsewhere in the API.
    limit: Int = 100

    # Order information. Default is order by `createdDateTime` descending.
    orderBy: [AuditLogOrderBy!]
  ): AuditLogEntryList!

  # Get the media share by media shareId
  mediaShare(id: ID!): MediaShare!

  # Retrieve a shared collection
  sharedCollection(
    # share token
    shareId: ID!
  ): SharedCollection

  # Retrieve shared collection history records
  sharedCollectionHistory(
    # Provide an ID to retrieve a single history record
    ids: [ID!]

    # Provide a folder ID to filter by collection
    folderId: ID

    # Provide a share ID to filter by share ID
    shareId: String

    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30
  ): SharedCollectionHistoryList!

  # Retrieve Workflow Metric of the current user's organization
  workflowMetric: WorkflowMetric!
  dailyTaskMetrics: DailyTaskMetricsList!

  # Retrieve Veritone Workflow instance status by id
  workflowRuntime(workflowRuntimeId: ID!): WorkflowRuntimeResponse!

  # Get a specific workflowRuntimeData based on dataKey
  workflowRuntimeStorageData(
    # Unique id of the workflow instance
    workflowRuntimeId: ID!

    # The unique id to rertrieve a single workflow data
    storageKey: String

    # A prefix filter used to return a set of workflow data
    # items whose dataKey starts with dataKeyPrefix
    storageKeyPrefix: String

    # Offset for paging
    offset: Int = 0

    # Limit on result size, for paging (page size).
    # workflowRuntimeData can be arbitrary large therefore smaller paging shoulf be preffered
    limit: Int = 30
  ): WorkflowRuntimeStorageDataList!

  # Get list process templates by id or current organizationId
  processTemplates(id: ID, offset: Int = 0, limit: Int = 30): ProcessTemplateList!

  # Get process templates by id
  processTemplate(id: ID!): ProcessTemplate!

  # Get creative by id with current organizationId
  creative(id: ID!): Creative!

  # Retrieve list of engine classes
  engineClasses(
    # Provide an ID to retrieve a single specific engine class.
    id: ID

    # Provide a name, or part of one, to search by class name
    name: String

    # Specify maximum number of results to retrieve in this result. Page size.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result.
    limit: Int = 30
  ): EngineClassList

  # Retrieve a specific engine class
  engineClass(
    # Supply the ID of the engine class to retrieve
    id: ID!
  ): EngineClass
  benchmarkJobs(offset: Int = 0, limit: Int = 30): BenchmarkJobs
  benchmarkJob(id: ID!): BenchmarkJob

  # Retrieve a single schedule
  scheduledJob(id: ID!): ScheduledJob

  # Retrieve or search for schedules
  scheduledJobs(
    # Provide an ID to retrieve a specific schedule
    id: ID

    # Provide a schedule name, or part of one, to search for schedules
    # by name. Supports prefix/like search.
    name: String

    # Specify a run mode to filter to run mode
    runMode: RunMode

    # Specify isActive true or false to filter by active state
    isActive: Boolean
    engineId: ID
    engineCategoryId: ID
    engineType: [EngineTypeFilter!]

    # Specify an offset to retrieve additional pages
    offset: Int = 0

    # Specify a limit to limit result size.
    limit: Int = 30
    dateTimeFilter: [ScheduledJobDateTimeFilter!]

    # Time filter is in station local time
    partTimeFilter: [ScheduledJobPartTimeFilter!]

    # Optionally, specify one or more source IDs. Scheduled jobs with
    # any of the given sources as their primary source will be returned.
    primarySourceId: [ID!]

    # Optionally, specify one or more source type IDs. Scheduled jobs with
    # any of the given sources types on their primary source will be returned.
    primarySourceTypeId: [ID!]
    hasJobTemplate: Boolean

    # Specify isRunning true or false to filter for scheduled jobs that
    # have jobs running right now.
    hasRunningJobs: Boolean

    # Order information. Default will order by modifiedDateTime descending.
    orderBy: [ScheduledJobOrderBy!]

    # Specify a permission level to retrieve scheduled jobs to which you
    # have at least that permission.
    permission: ScheduledJobPermission = viewer

    # Specify clusterId to filter scheduled jobs that run on specified cluster
    clusterId: ID
  ): ScheduledJobList

  # Retrieve a single engine configuration
  engineConfiguration(id: ID!): EngineConfiguration

  # Retrieve all engine configurations
  engineConfigurations(id: ID): EngineConfigurationList

  # Retrieve a single node
  clusterNode(id: ID!): ClusterNode!

  # Retrieve a list of nodes
  clusterNodes(id: ID, offset: Int = 0, limit: Int = 30): ClusterNodeList!

  # Retrieve a single cluster
  cluster(id: ID!): Cluster!

  # Retrieve a list of clusters
  clusters(
    id: ID
    name: String
    type: ClusterType
    nameMatch: StringMatch = contains
    offset: Int = 0
    limit: Int = 30

    # Type of string match to use against tags, if any
    tagMatch: StringMatch = startsWith

    # List of tags to match against
    tags: [String!]
    dateTimeFilter: [ClusterDateTimeFilter!]
    orderBy: [ClusterOrderBy!]

    # ID of the organization. Only Veritone platform components can set this value.
    organizationId: ID
  ): ClusterList!

  # Retrieve a single execution location
  executionLocation(id: ID!): ExecutionLocation!

  # Retrieve a list of execution locations
  executionLocations(id: ID): ExecutionLocationList!

  # Retrieve a single job template
  jobTemplate(id: ID!): JobTemplate!

  # Retrieve a list of job templates for a given job pipelineId
  jobTemplates(jobPipelineId: ID, scheduledJobId: ID, engineId: ID, engineType: [EngineTypeFilter!], offset: Int = 0, limit: Int = 30): JobTemplateList!

  # Retrieve a single task template
  taskTemplate(id: ID!): TaskTemplate!

  # Retrieve a single job pipeline
  jobPipeline(id: ID!): JobPipeline!

  # Retrieve a list of job pipelines owned by org
  jobPipelines(id: ID, scheduledJobId: ID, isPublic: Boolean, offset: Int = 0, limit: Int = 30): JobPipelineList!

  # Retrieve a single source
  source(id: ID!): Source!

  # Retrieve a list of sources
  sources(
    # Provide an ID to retrieve a specific source.
    id: ID

    # Provide a source type ID to filter for sources of the specified type.
    sourceTypeId: ID
    sourceTypeIds: [ID]

    # Provide a name or partial name value to filter by name.
    # The `nameMatch` parameter can be used to determine the string
    # match strategy used in the filter. Default is "starts with".
    # Note that all matching is case-insensitive.
    name: String

    # String matching strategy. Default is "starts with".
    nameMatch: StringMatch = startsWith

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Set this flag to true or false to return only sources that do or do
    # not have content templates associated with them.
    # The default is neither (do not filter on the presence of content templates).
    hasContentTemplates: Boolean

    # Set this flag to true to include public sources or false to include
    # only sources owned by the
    # user's org, not public sources.
    # Public sources owned by the caller's org will always be returned.
    includePublic: Boolean = true

    # Provide a correlation schama ID to filter for sources that correlate using specified schema.
    correlationSchemaId: ID

    # Provide optional sort information. If not provided, a default sort
    # by createdDateTime descending will be applied.
    orderBy: [SourceSortField!]

    # Specify a permission level to retrieve sources to which you
    # have at least that permission.
    permission: SourcePermission = viewer
  ): SourceList!

  # Retrieve a single source type
  sourceType(id: ID!): SourceType!

  # Retrieve a list of source types
  sourceTypes(
    id: ID
    ids: [ID]

    # Provide a source type category ID to select source types belonging
    # to the category
    categoryId: ID

    # Provide `isLive` to select source types with the given value.
    isLive: Boolean
    offset: Int = 0
    limit: Int = 30
  ): SourceTypeList!

  # Retrieve all source type categories
  sourceTypeCategories(
    # Optionally, provide a source category type ID.
    id: ID
  ): SourceTypeCategoryList!

  # Retrieve a single source type category
  sourceTypeCategory(id: ID!): SourceTypeCategory!

  # Retrieve a single external credential
  externalCredential(id: ID!): ExternalCredential!

  # Retrieve a list of external credentials
  externalCredentials(id: ID): ExternalCredentialList!
  tasks(id: ID, taskTemplateId: ID): TaskList

  # matching cluster tags in use by this organization
  clusterTags(matchType: StringMatch = startsWith, match: String!): [String!]!
}

input ReplaceSavedSearch {
  id: ID!
  name: String!
  sharedWithOrganization: Boolean = false
  csp: JSON!
}

input RequestClone {
  sourceApplicationId: ID!
  destinationApplicationId: ID!
  cloneBlobs: Boolean = false
}

input RevertScheduledJob {
  id: ID!
}

type RightsListing {
  operations: [String!]!
  resources: JSON
}

# A role signifies a user's permissions within a given context.
type Role {
  description: String
  appName: String
  name: String!
  permissions: PermissionList
  id: ID!
}

enum RootFolderType {
  watchlist
  collection
  cms
}

enum RunMode {
  Continuous
  Recurring
  Once
  Now
}

type SavedSearch {
  id: ID!
  organizationId: ID!
  organization: Organization
  ownerId: ID!
  owner: User
  name: String!
  sharedWithOrganization: Boolean
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  csp: JSON
}

type SavedSearchList implements Page {
  records: [SavedSearch!]
  count: Int
  offset: Int!
  limit: Int!
}

enum SavedSearchOrderBy {
  name
  createdDateTime
  sharedWithOrganization
}

type ScheduledJob {
  id: ID!
  organizationId: ID

  # Organization that owns this scheduled job
  organization: Organization
  name: String
  description: String
  startDateTime: DateTime
  stopDateTime: DateTime
  jobPipelineIds: [ID!]
  jobPipelines(offset: Int = 0, limit: Int = 30): JobPipelineList!
  jobTemplateIds: [ID!]
  jobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  # Retrieve the complete set of job templates associated with this
  # scheduled job, including those that are associated through a job
  # pipeline.
  allJobTemplates(offset: Int = 0, limit: Int = 30): JobTemplateList!

  # The ID of the primary source on this scheduled job, if applicable.
  # This is based on the payloads of the tasks that are invoked for
  # this scheduled job.
  primarySourceId: ID

  # The primary source. See `primarySourceId` above.
  primarySource: Source
  jobs(
    # Optionally, specify a TDO ID to filter by job target
    targetId: ID

    # Optionally, specify a cluster ID to filter by cluster
    clusterId: ID

    # Provide sort information. The default is to sort by
    # createdDateTime descending.
    orderBy: [JobSortField!]

    # Optionally, specify filters on date/time fields.
    # If a filter is not provided here, the query will
    # default to the past 3 months.
    dateTimeFilter: [JobDateTimeFilter!]

    # Provide a list of status strings to filter by status
    status: [JobStatusFilter!]

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify the maximum number of results to included in this response, or page size.
    limit: Int = 30
  ): JobList!

  # Get a list of sources that are used
  # by engine configurations that reference
  # this schedule through the schedule -> job -> task relationship.
  sources(offset: Int = 0, limit: Int = 30): SourceList
  parts: [SchedulePart!]
  isActive: Boolean!
  runMode: RunMode!
  details: JSON
  detailsSchemaId: ID
  createdDateTime: DateTime
  modifiedDateTime: DateTime

  # List of schema-controlled content templates attached
  # to this scheduled job
  contentTemplates: [ScheduledJobContentTemplate!]!

  # Permissions granted to other organizations. Only the source owner
  # can view or edit this field.
  collaborators: ScheduledJobCollaboratorList!

  # A public scheduled job can be viewed and launched by
  # users from any organization. By default, scheduled jobs are
  # private and can only be viewed or launched by the owning organization
  # and organizations that the owner has explicitly shared them with.
  # Only Veritone administrators can create public scheduled jobs.
  isPublic: Boolean

  # The user's permission on this scheduled job
  permission: ScheduledJobPermission
  primarySourceTypeId: ID
  primarySourceType: SourceType
  ingestionStatusId: ID
  ingestionStatus: String
  affiliates: ProgramAffiliateList!
}

# A source ACL grants a single organization limited rights to a private source
type ScheduledJobCollaborator {
  # The permission granted. Either `viewer` or `editor`.
  permission: ScheduledJobPermission!

  # Organization ID the source was shared with
  organizationId: ID!

  # The organization the source was shared with
  organization: Organization
}

type ScheduledJobCollaboratorList implements Page {
  records: [ScheduledJobCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

type ScheduledJobContentTemplate {
  id: ID!
  scheduledJobId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

enum ScheduledJobDateTimeField {
  startDateTime
  stopDateTime
  dateCreated
  dateModified
}

input ScheduledJobDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: ScheduledJobDateTimeField!
  includeEmpty: Boolean
}

type ScheduledJobList implements Page {
  records: [ScheduledJob!]!
  count: Int!
  offset: Int!
  limit: Int!
}

input ScheduledJobOrderBy {
  field: ScheduledJobOrderField!
  direction: OrderDirection = desc
}

enum ScheduledJobOrderField {
  id
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
  name
  runMode
  isActive
}

enum ScheduledJobPartTimeField {
  startTime
  endTime
}

input ScheduledJobPartTimeFilter {
  toTime: Time
  fromTime: Time
  field: ScheduledJobPartTimeField!
}

# Permissions or roles on source objects
enum ScheduledJobPermission {
  # A source editor can make updates to some source fields, but cannot
  # delete or share the source.
  editor

  # A viewer can view the source and use it in ingestion jobs,
  # but not make any updates to it.
  viewer

  # A source owner has full rights to update and delete the source.
  owner
}

type SchedulePart {
  scheduleType: ScheduleType!

  # The day of week adjusted to source live timezone
  scheduledDayLocal: DayOfWeek
  scheduledDay: DayOfWeek
  startTime: Time
  stopTime: Time
  repeatIntervalUnit: IntervalUnit
  repeatInterval: Int
  durationSeconds: Int
}

enum ScheduleType {
  Weekly
  Interval
}

type Schema {
  id: ID!
  dataRegistryId: ID!
  dataRegistry: DataRegistry
  definition: JSON
  majorVersion: Int!
  minorVersion: Int!
  createdBy: User
  modifiedBy: User
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  status: SchemaStatus

  # List of status the Schema can transition to.
  validActions: [SchemaAction]

  # SDOs under this schema
  structuredDataObjects(offset: Int = 0, limit: Int = 30): StructuredDataList

  # The organization that owns this schema.
  organization: Organization

  # The Id of the organization that owns this schema.
  organizationId: ID
}

enum SchemaAction {
  view
  edit
  publish
  deactivate
  delete
}

type SchemaList implements Page {
  records: [Schema]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

input SchemaOrder {
  field: SchemaOrderFields!
  direction: OrderDirection = desc
}

enum SchemaOrderFields {
  majorVersion
  minorVersion
  status
  createdDateTime
  modifiedDateTime
}

enum SchemaOwnership {
  mine
  others
  all
}

type SchemaProperty {
  dataRegistryId: ID!
  majorVersion: Int!
  schema: Schema!
  path: String!
  searchPath: String!
  type: String!
  title: String
}

type SchemaPropertyList implements Page {
  records: [SchemaProperty]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum SchemaStatus {
  published
  deleted
  draft
  inactive
}

enum ScopeRequirement {
  Any
  All
}

type SearchFieldConfig {
  searchField: String
  indexField: String
}

enum SearchIndex {
  mine
  global
}

input SearchInput {
  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int = 0

  # Maximum number of results that were retrieved in this query; page size
  limit: Int = 0
  index: [String]!
  query: JSON!
  select: JSON
}

# Results from a mention or media search.
# See https://docs.veritone.com/#/apis/search-quickstart for full details on the search result syntax
type SearchResult {
  jsondata: JSON!
}

# Contains security settings on an asset container
type Security {
  # Whether or not the object is globally visible
  global: Boolean
}

input SendEmail {
  from: String!
  to: String!
  subject: String!

  # Message can be either text or HTML
  message: String!
  replyTo: String!
}

# Input type for AssetFileData
input SetAssetFileData {
  # The MD5 checksum of the file
  md5sum: String

  # The file size in bytes
  size: Int

  # Original file URI, if provided on asset creation
  originalFileUri: String

  # The insertion mode of the asset
  mode: AssetCreationMode = create

  # Media duration in milliseconds
  mediaDurationMs: Int
}

# Input type for AssetSourceData
input SetAssetSourceData {
  # The name of the asset source engine or engine category
  name: String

  # ID of the specific task that created the asset
  taskId: ID

  # ID of the engine that created the asset
  engineId: ID

  # Optional ID of the source from which this asset
  # was created. This field will typically be set only
  # by adapters that ingest data.
  sourceId: ID

  # Optional ID of the scheduled job that created this asset
  scheduledJobId: ID

  # Optional ID of the asset this asset was created from.
  # This will usually be assets with edits to a previous
  # asset.
  assetId: ID
}

enum SetClusterPermission {
  viewer
  none
}

input SetEngineBlacklist {
  # Provide the organization ID to update. This field is required only
  # when using addToEngineBlacklist or deleteFromEngineBlacklist.
  organizationId: ID

  # Provide the IDs of engines to set.
  engineIds: [ID!]

  # Provide the IDs of engine categories to set.
  engineCategoryIds: [ID!]
}

input SetEngineWhitelist {
  # Provide the organization ID to update. This field is required only
  # when using addToEngineWhitelist or deleteFromEngineWhitelist.
  organizationId: ID
  engineIds: [ID!]
}

# Settings that determine when to set a new entity identifier
# as the entity profile image.
enum SetEntityProfileImage {
  # Do not update the entity profile image
  none

  # Set the the entity identifier URL as the entity profile image
  # only if there is no current profile image. Will cause an error
  # if the entity identifier type is not an image.
  ifNotSet

  # Set the entity identifier as the new entity profile image,
  # overwriting whatever value is present. Will cause an error
  # if the entity identifier type is not an image.
  always
}

input SetOrganizationIntegrationConfig {
  # input organizationId
  organizationId: ID!

  # input integrationId
  integrationId: String!

  # If userVisible is set to true, then this can be accessed
  # by any type of auth token
  # (as long as the user belongs to that organization or is a superadmin).
  # If userVisible is set to false, then this can only be
  # accessed by an API key of that org or by superadmins.
  userVisible: Boolean!

  # The JSON config of organization integration
  config: JSON!
}

# Input used to set the primary asset of a given type on a TDO.
# The type must be supported by the server; primary asset is used
# by certain engines and front end components.
# Currently "media" and "transcript" are supported.
input SetPrimaryAsset {
  # ID of the asset
  id: ID!

  # The asset type -- "media" or "transcript"
  assetType: String!
}

enum SetScheduledJobPermission {
  viewer
  editor
  none
}

enum SetSourcePermission {
  viewer
  editor
  none
}

# Identifies the task that created a TDO.
input SetTDOSourceData {
  # ID of the task that created this TDO
  taskId: ID

  # Optional ID of the source from which this TDO's initial
  # data was created. This field will typically be set only
  # by adapters that ingest data and create TDOs.
  sourceId: ID

  # Optional ID of the scheduled job that created this TDO.
  scheduledJobId: ID
}

type Share {
  id: ID!
  type: ShareType
  recipients: [String]
  shareMessage: String
  shareOptionsJson: JSON
  folderId: ID
  mentionId: ID
  mediaShare: MediaShareInfo
}

input ShareCollection {
  # id of the collection
  folderId: ID!

  # message in email
  shareMessage: String

  # list of recipients
  recipients: [String]

  # collection specific share options
  shareOptions: ShareOptions
}

type SharedCollection {
  name: String
  description: String
  image: String

  # A signed url to get the collection image. It will only be signed if it is an s3 url.
  signedImageUrl: String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  folderId: ID
  folderTypeId: ID
  organizationId: ID
  programCount: Int
  shareInfo: Share
  itemCount: Int
  mentions(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): SharedMentionList
}

# Provides status information on the creation or update of a shared collection.
type SharedCollectionHistory {
  # History ID
  id: ID!

  # Type of history record, New, AddMention, or RemoveMention
  type: String!

  # The folder ID for the new or updated shared collection
  folderId: ID!

  # The share ID of the shared collection
  shareId: ID!

  # The status of the shared collection creation or update
  # Options: New, InProgress, Complete, Failed
  status: SharedCollectionHistoryStatus!
  mentionId: ID

  # Number of times the creation or update has been retried
  retryCount: Int

  # Creation date of this history record
  createdDateTime: DateTime!

  # Last modified date of this history record
  modifiedDateTime: DateTime!
}

type SharedCollectionHistoryList implements Page {
  # Count of records in this page. Will be less than or equal to `limit`.
  count: Int

  # Offset used in the query that generated this page.
  offset: Int!

  # Limit used in the query that generated this page.
  limit: Int!

  # List of shared collection history records
  records: [SharedCollectionHistory]
}

enum SharedCollectionHistoryStatus {
  New
  InProgress
  Complete
  Failed
}

enum SharedCollectionUpdateType {
  # Indicates a mention has to be added to the shared collection
  AddMentions

  # Indicates a mention has to be removed from the shared collection
  RemoveMentions

  # Indicates a mention has to be updated so the shared mention details needs to be updated
  UpdateMentions
}

type SharedMention {
  id: ID!
  organizationId: ID!
  sourceTypeId: ID
  sourceId: ID
  scheduledJobId: ID
  mediaId: ID
  advertiserId: ID
  brandId: ID
  campaignId: ID
  watchlistId: ID
  statusId: ID
  complianceStatusId: ID
  spotTypeId: ID
  audienceMarketCount: Int
  audienceAffiliateCount: Int
  mentionHitCount: Int
  audience: Int
  mentionRating: Int
  isMatch: Boolean
  mentionDate: DateTime
  metadata: JSON
  mentionSnippets: [MentionSnippets]
  userSnippets: [MentionUserSnippets]
  adCreative: JSON
  fingerprint: JSON
  cognitiveEngineResults: JSON
  comments: [MentionComment]
  hash: ID
  hitStartDateTime: DateTime
  hitEndDateTime: DateTime
  organization: JSON
  temporalDataObject: JSON
  scheduledJob: JSON
  share: Share
  watchlist: JSON

  # The shared mention description if it is in a collection
  description: String
}

type SharedMentionList implements Page {
  records: [SharedMention]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type SharedWith {
  # List of organizationIds that have read access to this object
  read: [Int]

  # List of organizationIds that have write access to this object
  write: [Int]
}

input ShareFolderInput {
  # The treeObjectId of the Folder to share
  treeObjectId: ID!

  # The organizations that will have read permissions to the Folder
  readOrganizationIds: [Int]

  # The organizations that will have write permissions to the Folder
  writeOrganizationIds: [Int]
}

input ShareMention {
  # id of the mention
  mentionId: ID!

  # message in email
  shareMessage: String

  # list of recipients
  recipients: [String]

  # app specific share options
  shareOptions: JSON

  # Internal API token can create shared mention for other orgs
  organizationId: ID

  # UserID the shared mention is being created for
  userId: ID
}

input ShareMentionFromCollection {
  # id of the mention from collection
  mentionId: ID!

  # id of the collection
  folderId: ID!

  # message in email
  shareMessage: String

  # list of recipients
  recipients: [String]

  # Collection image
  shareOptions: ShareOptions
}

input ShareMentionInBulk {
  # Array ids of the mentions
  mentionIds: [ID!]!

  # message in email
  shareMessage: String

  # list of recipients
  recipients: [String]

  # Collection image
  shareOptions: JSON
}

input ShareOptions {
  showImage: Boolean
  showComments: Boolean
  showRating: Boolean
  showHeader: Boolean
  showOrganizationLogo: Boolean
  organizationLogoUrl: Boolean
  showEngineResults: Boolean
  showHits: Boolean
  showAffiliateStripdown: Boolean
  showDownload: Boolean
  showDescription: Boolean
  mentionPrePaddingSeconds: Float
  mentionPostPaddingSeconds: Float
}

enum ShareType {
  collection
  mention
}

# A source represents a source of data and is used by adapters to ingest
# data into the platform for use by an engine workflow.
type Source {
  # Unique ID of this source
  id: ID!

  # ID of the source type for this source.
  sourceTypeId: ID!

  # The source type for this source
  sourceType: SourceType

  # A name for this source
  name: String!

  # Metadata associated with this source. The schema for this data is
  # specific to the source type and controlled by a schema.
  details: JSON

  # Indicates whether this source is public and available to all organizations
  # or restricted to the organization that owns id.
  isPublic: Boolean!

  # ID of the organization that owns this source
  organizationId: ID!

  # The organization that owns this source
  organization: Organization

  # Date and time this source was created
  createdDateTime: DateTime

  # Date and time this source was last modified
  modifiedDateTime: DateTime

  # An optional thumbnail image URL for the source
  thumbnailUrl: String
  contentTemplates: [SourceContentTemplate!]!

  # Id of a published data registry schema
  correlationSchemaId: ID

  # Id of a structured data object for the correlationSchemaId
  correlationSDOId: ID

  # permission the currently authenticated principal has on this source.
  permission: SourcePermission!

  # Permissions granted to other organizations. Only the source owner
  # can view or edit this field.
  collaborators(orderBy: SourceCollaboratorOrderBy = organizationId, orderDirection: OrderDirection = asc): SourceCollaboratorList!

  # Current state for the source object. This is controlled by
  # the adapters that use the source and should not be set by
  # other clients.
  state: JSON
}

# A source ACL grants a single organization limited rights to a private source
type SourceCollaborator {
  # The permission granted. Either `viewer` or `editor`.
  permission: SourcePermission!

  # Organization ID the source was shared with
  organizationId: ID!

  # The organization the source was shared with
  organization: Organization
}

type SourceCollaboratorList implements Page {
  records: [SourceCollaborator!]!
  offset: Int!
  limit: Int!
  count: Int
}

enum SourceCollaboratorOrderBy {
  organizationId
  permission
}

type SourceContentTemplate {
  id: ID!
  sourceId: ID!
  sdoId: ID!
  sdo: StructuredData
  schemaId: ID!
  data: JSON
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type SourceList implements Page {
  records: [Source!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# Source list sort field options
enum SourceOrderField {
  createdDateTime
  modifiedDateTime
  id
  name
  sourceTypeId
}

# Permissions or roles on source objects
enum SourcePermission {
  # A source editor can make updates to some source fields, but cannot
  # delete or share the source.
  editor

  # A viewer can view the source and use it in ingestion jobs,
  # but not make any updates to it.
  viewer

  # A source owner has full rights to update and delete the source.
  owner
}

# Source list sort information
input SourceSortField {
  # Specify the field to sort by. Required.
  field: SourceOrderField!

  # Specify the sort direction. Default is descending.
  direction: OrderDirection = desc
}

# A source type represents a category of sources that share common
# attributes, such as "TV station" or "Real-time camera feed".
type SourceType {
  # Unique ID of this source type
  id: ID!

  # A name for this source type
  name: String!
  organizationId: ID
  isPublic: Boolean

  # The ID of an optional schema for instances (sources) of
  # this source type
  sourceSchemaId: ID

  # The icon representing the type of source
  iconClass: String

  # The schema object used to validate details for instances (sources)
  # of this source type
  sourceSchema: Schema

  # The ID of an optional schema for credentials associated with
  # sources of this type.
  credentialSchemaId: ID

  # The schema used to validate credentials associated with sources
  # of this type.
  credentialSchema: Schema

  # Date and time this object was created.
  createdDateTime: DateTime

  # Date and time this object was last modified
  modifiedDateTime: DateTime
  credentialType: CredentialType

  # Indicates whether or not the source is "live", such as a camera feed
  isLive: Boolean

  # Indicates whether the source requires a scan job pipeline
  requiresScanPipeline: Boolean
  supportedRunModes: [RunMode!]!

  # The source type category ID for this source type.
  # Used primarily by Veritone platform components.
  categoryId: ID!

  # The source type category for this source type.
  # Used primarily by Veritone platform components.
  category: SourceTypeCategory!

  # List of source formats applicable to this source type.
  # Only applies to certain source types; many will have an
  # empty list.
  sourceFormats: [String!]!

  # List of program formats applicable to this source type.
  # Only applies to certain source types; many will have an
  # empty list.
  programFormats: [String!]!

  # Sources created under this source type
  sources(
    # Optionally, provide a list of IDs to retrieve sources by ID
    id: [ID!]

    # Provide a name or partial name value to filter by name.
    # The `nameMatch` parameter can be used to determine the string
    # match strategy used in the filter. Default is "starts with".
    # Note that all matching is case-insensitive.
    name: String

    # String matching strategy. Default is "starts with".
    nameMatch: StringMatch = startsWith

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30

    # Set this flag to true or false to return only sources that do or do
    # not have content templates associated with them.
    # The default is neither (do not filter on the presence of content templates).
    hasContentTemplates: Boolean

    # Set this flag to true to include public sources or false to include
    # only sources owned by the
    # user's org, not public sources.
    # Public sources owned by the caller's org will always be returned.
    includePublic: Boolean = true

    # Provide a correlation schama ID to filter for sources that correlate using specified schema.
    correlationSchemaId: ID

    # Provide optional sort information. If not provided, a default sort
    # by createdDateTime descending will be applied.
    orderBy: [SourceSortField!]
  ): SourceList!
}

# Source type categories are managed by Veritone.
type SourceTypeCategory {
  id: ID!
  name: String!
}

type SourceTypeCategoryList implements Page {
  records: [SourceTypeCategory!]!
  limit: Int!
  offset: Int!
  count: Int
}

type SourceTypeList implements Page {
  records: [SourceType!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# Used to control string matching on fields that support it
enum StringMatch {
  # Match if the target string field starts with the supplied value.
  # Case-insensitive.
  startsWith

  # Match if the target string field ends with the supplied value.
  # Case-insensive.
  endsWith

  # Match if the target string field contains the supplied value
  # anywhere in its content. Use only when strictly necessary, as
  # startsWith and endsWith offer better performance.
  # Case-insensitive.
  contains

  # Match if the target string field exactly matches the
  # supplied value. Case-insensitive.
  exact
}

# Type representing a string property
type StringProperty implements Property {
  name: String!
  value: String
}

type StructuredData {
  # The ID
  id: ID!

  # Id of the schema used to validate this object
  schemaId: ID!

  # The schema used to validate this object
  schema: Schema
  data(
    # Optionally, specify a path into the JSON data.
    # Only the value of the path will be returned, at the
    # top level. The value will be empty if there is nothing
    # in the JSON at that path.
    # This parameter is useful for directly addressing fields in the JSON.
    path: String
  ): JSON
  dataString(indent: Int = 0): String
  createdDateTime: DateTime
  modifiedDateTime: DateTime
}

type StructuredDataList implements Page {
  records: [StructuredData]
  count: Int
  offset: Int!
  limit: Int!
  owned: Boolean
  orderBy: [StructuredDataOrderByType!]
}

input StructuredDataOrderBy {
  field: StructuredDataOrderByField!
  direction: OrderDirection = desc
}

enum StructuredDataOrderByField {
  createdDateTime
  modifiedDateTime
}

type StructuredDataOrderByType {
  field: StructuredDataOrderByField!
  direction: OrderDirection!
}

# An object containing custom structured data.
# This type is not fully implemented.
type StructuredJSONObject implements Metadata {
  data: JSON
  schema: StructuredJSONSchema!
  name: String!
  id: ID!
}

# A custom structured data schema, specified in JSON.
# This type is not fully implemented.
type StructuredJSONSchema {
  schema: JSON
  name: String!
  id: ID!
  ownerOrganizationId: ID!
  organization: Organization!
}

input SubscribeEvent {
  # Existing event name
  eventName: String

  # Existing event type
  eventType: String

  # Identifier of the app using the event
  application: String!

  # a string payload, it should be serialized Protobuf data with base64 encoding
  delivery: EventDelivery!

  # The conditions to filter the event
  conditions: JSON
}

type Subscription {
  id: ID!
  organizationId: ID!
  objectType: SubscriptionObjectType!
  frequency: SubscriptionFrequency!
  createdDateTime: DateTime
  modifiedDateTime: DateTime
  isActive: Boolean!

  # The ID of the object on which this subscription is set,
  # such as a watchlist ID.
  targetId: ID!

  # Scheduled time of day
  scheduledTime: Time

  # Time zone of the scheduled time
  scheduledTimeZone: String

  # Scheduled day of the week
  scheduledDay: DayOfWeek
  jsondata: JSON
  contact: SubscriptionContact!
  unsubscribeHash: String
}

type SubscriptionContact {
  userId: ID!
  emailAddress: String
  phoneNumber: String
  webhookUri: String
}

enum SubscriptionFrequency {
  immediate
  daily
  weekly
  never
}

enum SubscriptionObjectType {
  mention
}

enum SupportedGPU {
  G2
  G3
  P2
}

type SystemEventInfo {
  topic: String!
  payload: JSON!
  timestamp: DateTime!
  id: ID!
}

# Represents a single engine task
type Task {
  # The task ID
  id: ID!
  name: String
  description: String

  # Date and time the task was created
  createdDateTime: DateTime

  # Date and time the task was last modified
  modifiedDateTime: DateTime
  createdBy: String
  modifiedBy: String

  # Date and time the task was queued for execution.
  queuedDateTime: DateTime

  # Date and time the task completed.
  completedDateTime: DateTime

  # Date and time task execution started
  startedDateTime: DateTime

  # The task status. See TaskStatus enum for details.
  status: TaskStatus

  # Optional order in which the task should run, relative to other tasks
  # in the job that contains it.
  order: Int

  # Whether or not the task is run on the clone of a TDO
  isClone: Boolean

  # Application ID that owns the task
  applicationId: String

  # The ID of the TemporalDataObject the task
  # was created for.
  targetId: ID

  # The TemporalDataObject the task was created for.
  target: TemporalDataObject

  # ID of the engine for the task.
  engineId: ID

  # The engine for the task
  engine: Engine

  # The ID of the job that contains this task
  jobId: ID

  # The job that contains this task.
  job: Job

  # ID of the engine build used for this task.
  buildId: ID

  # The engine build used for this task
  build: Build

  # The source asset for this task, if there is one.
  sourceAsset: Asset

  # The ID of the source asset for this task, if there is one.
  sourceAssetId: ID
  mediaLengthSec: Int
  mediaStorageBytes: Int
  mediaFileName: String

  # The incoming task payload, in JSON format
  payload: JSON

  # The task output, in JSON format.
  output: JSON

  # The incoming task payload, in String format.
  payloadString: String

  # The task output, in String format.
  outputString: String

  # The log file produced during task execution
  log: TaskLog

  # For backwards compatibility only
  taskPayload: JSON

  # For backwards compatibility only
  taskOutput: JSON

  # True if this task was created as a test task
  testTask: Boolean
  parentTaskId: ID
  parentTask: Task
  childTaskIds: [ID!]
  childTasks: [Task!]

  # A standby task that will execute if this one fails.
  standbyTask: Task

  # The task that this task is a standby for. If the task
  # identified in this field fails, the current task will execute.
  standbyForTask: Task

  # Contains metadata used by the platform run-time system to execute
  # the task. This field is accessible only to platform components.
  runtimePayload: JSON

  # Failure reason code. This will be set only if the task final status
  # was `failed`.
  failureReason: TaskFailureReason

  # Failure message from the engine. This will be set only if the task final
  # status was `failed` and `failureReason` is set.
  failureMessage: String
  engineConfiguration: EngineConfiguration
  engineConfigurationId: ID
  executionLocation: ExecutionLocation
  executionLocationId: ID
  templateId: ID
  template: TaskTemplate
}

enum TaskDateTimeField {
  createdDateTime
  modifiedDateTime
}

input TaskDateTimeFilter {
  toDateTime: DateTime
  fromDateTime: DateTime
  field: TaskDateTimeField!
}

# Need to keep in sync with https://github.com/veritone/edge-messages/blob/master/failure_reason.go
enum TaskFailureReason {
  # The engine encountered an unexpected internal error.
  internal_error

  # The cause of the failure could not be determined.
  unknown

  # The engine attempted to download
  # content from a URL provided in the task payload and
  # received a 404.
  url_not_found

  # The engine attempted to download
  # content from a URL provided in the task payload and
  # received a 401 or 403.
  url_not_allowed

  # The engine attempted to download
  # content from a URL provided in the task payload and
  # the download timed out
  url_timeout

  # The engine attempted to download
  # content from a URL provided in the task payload and
  # the connection was refused.
  url_connection_refused

  # The engine attempted to download content from a URL
  # provided in the task payload an received an error.
  url_error

  # The input to the engine was incompatible with the engine
  # requirements. For example, an input media file had an
  # unsupported MIME type or the file was empty.
  invalid_data

  # An engine operation was subject to rate limiting.
  rate_limited

  # The engine received an authorization error from the Veritone API.
  api_not_allowed

  # The engine received an authentication error from the Veritone API using
  # the token provided in the task payload.
  api_authentication_error

  # The engine received a "not found" error from the Veritone API on
  # a required object.
  api_not_found

  # An unexpected error was received from the Veritone API, such as
  # HTTP 500, HTTP 502, or an `internal_error` error.
  api_error

  # The engine could not write temporary files to disk for processing
  # due to disk space full or other system error.
  file_write_error

  # The engine could not read from stream input for processing
  # due to stream link broken or cannot connect to stream link
  stream_read_error

  # The engine encountered a missing binary dependency or configuration,
  # such as a missing executable or package or incompatible hardware.
  system_dependency_missing

  # The engine encountered an operating system, hardware, or other
  # system-level error.
  system_error

  # The engine failed to send heartbeat or Edge didn't receive it in time
  heartbeat_timeout

  # The engine failed to send chunk result, or Edge didn't receive it in time
  chunk_timeout

  # The error cause is known, but could not be mapped to a `TaskFailureReason`
  # value. The `failureMessage` input field should contain details.
  other

  # The engine calls third party for processing and receives error
  external_error
}

type TaskList implements Page {
  records: [Task]

  # The starting index for records that were returned in this query.
  offset: Int!
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type TaskLog {
  # URI to the task log file
  uri: String

  # The entire text contents of the log file. Note that this value can long.
  text: String

  # The log file in JSON form. If the log file contains valid JSON,
  # this field will contain the native structure. If the log file does not
  # contain valid JSON, this field will contain a single property called
  # `text` with a string value containing the entire log file.
  jsondata: JSON
}

enum TaskStatus {
  pending
  running
  complete
  queued
  accepted
  failed
  cancelled
  standby_pending
  waiting
  resuming
  aborted
  paused
}

type TaskTemplate {
  id: ID!
  engineId: ID
  engine: Engine
  engineConfigId: ID
  engineConfig: EngineConfiguration
  executionLocationId: ID
  executionLocation: ExecutionLocation
  jobTemplateId: ID
  jobTemplate: JobTemplate
  payload: JSON
  payloadString: String
  parentTaskId: ID
  parentTask: Task
  childTaskIds: [ID!]!
  childTasks: TaskTemplateList!
}

type TaskTemplateList implements Page {
  records: [TaskTemplate!]!
  count: Int!
  offset: Int!
  limit: Int!
}

# Options used by the cleanupTDO mutation to select which data is deleted.
enum TDOCleanupOption {
  # Indicates that all assets should be deleted from storage, including
  # those used to store engine results. Metadata about the assets will remain
  # until the container TemporalDataObject is permanently deleted.
  storage

  # Indicates that all search index data should be deleted. The TemporalDataObject
  # and its assets will no longer be accessible through search.
  searchIndex

  # Indicates that engine results stored on related task objects should be deleted.
  # Engine results stored as assets will remain until assets are removed
  # using the storage option.
  engineResults
}

type TDOList implements Page {
  records: [TemporalDataObject]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

# Describes source information about a TDO. That is,
# the components and processes that produced it.
# Each field may or may not have a value, depending on
# how the TDO was created.
type TDOSourceData {
  # Task ID, typically of an ingestion task.
  taskId: ID

  # The task object.
  task: Task

  # Ingestion source ID
  sourceId: ID

  # ID of the scheduled job, if any, under which this TDO was created
  scheduledJobId: ID

  # ID of the engine used in the task that created this TDO
  engineId: ID

  # The engine used in the task that created this TDO.
  engine: Engine

  # The scheduled job under which this TDO was created, if any
  scheduledJob: ScheduledJob

  # The source from which this TDO was created, if any
  source: Source
}

# Describes a stream that is available on a TDO
type TDOStreamData {
  # The stream URI
  uri: String!

  # The protocol, such as "dash" or "hls"
  protocol: String!
}

type TDOStreamManifest {
  segments: [JSON!]
  initSegment: JSON
}

type TemporalDataObject {
  # Object creation timestamp. Does not change. In seconds since epoch (TODO change!).
  createdDateTime: DateTime

  # Object modification timestamp. In seconds since epoch (TODO change!).
  modifiedDateTime: DateTime

  # The object's unique ID
  id: ID!
  createdBy: String
  modifiedBy: String
  description: String
  name: String
  mediaId: ID @deprecated(reason: "Duplicate, redundant field")

  # An optional URL for a thumbnail or preview image for
  # this object. If the URL is to an object in Veritone's
  # object storage, it will be signed.
  thumbnailUrl: String

  # An optional URL for a preview asset for this document
  # object. If the URL is to an object in Veritone's
  # object storage, it will be signed.
  previewUrl: String

  # An optional URL for a source image for this object.
  # If the URL is to an object in Veritone's
  # object storage, it will be signed.
  sourceImageUrl: String

  # Modular metadata
  metadata: [Metadata] @deprecated(reason: "Duplicate, redundant field")

  # Direct access to metadata in raw JSON format
  jsondata: JSON @deprecated(reason: "Duplicate, redundant field")
  details(
    # optionally, specify a path to retrieve only a specific property
    # within the details JSON
    path: String
  ): JSON

  # Assets this object contains. Can be of any size.
  # This field does not support paging.
  assets(
    # Provide an ID to retrieve a single asset.
    id: ID

    # deprecated - use assetType parameter
    type: [String!]

    # Specify a list of asset types such as "media" or "transcript" to
    # retrieve a specific asset type.
    # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
    assetType: [String!]

    # Retrieve assets created by a specific task
    sourceTaskId: ID

    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
    orderBy: AssetOrderBy = createdDateTime
    orderDirection: OrderDirection = desc

    # Whether or not to include a virtual media asset
    # that streams together all segments on a segmented
    # TDO. Most clients should use the default for this.
    includeVirtualMediaAsset: Boolean = true
  ): AssetList
  assetCount: Int!

  # Retrieve the primary asset of a given type
  primaryAsset(assetType: String!): Asset

  # Security settings for the asset container
  security: Security

  # Recording start time. In seconds since epoch.
  startDateTime: DateTime!

  # Recording stop time. In seconds since epoch.
  stopDateTime: DateTime!
  source: String

  # The "application ID" of the organization that owns this TDO.
  # Maps directly to an organization ID.
  applicationId: ID! @deprecated(reason: "Duplicate, redundant field")

  # The ID of the organization that owns this TDO.
  organizationId: ID!

  # The organization that owns this TDO
  organization: Organization

  # status. Downloaded, recording, etc.
  status: String

  # Tasks running against this TemporalDataObject
  tasks(
    id: ID
    offset: Int = 0
    limit: Int = 30
    hasSourceAsset: Boolean

    # If a filter is not provided, a default of `createdDateTime` between
    # the TDO creation time and the current date will be applied.
    dateTimeFilter: [TaskDateTimeFilter]
  ): TaskList

  # Jobs running against this temporalDataObject
  jobs: JobList

  # Folders that this TDO is filed in
  folders: [Folder!]
  sourceData: TDOSourceData

  # If this TDO supports streams, contains stream listings.
  # Might be an empty list but will not be null.
  streams: [TDOStreamData!]!

  # Statuses of the engines run on the TDO.
  engineRuns(offset: Int = 0, limit: Int = 100): EngineRunList

  # If this is a segmented TDO, returns the stream manifest
  # contents in normalized JSON form.
  streamManifest: TDOStreamManifest

  # Indicates whether or not media contained in this TDO is
  # public (accessible to all orgs).
  isPublic: Boolean
}

enum TemporalDataObjectDateTimeField {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

# Specify a filter on a TemporalDataObject date/time field.
# At least one of `toDateTime` and `fromDateTime` must be provided.
input TemporalDataObjectDateTimeFilter {
  # Match if the field value is `toDateTime` or earlier
  toDateTime: DateTime

  # Whether the toDateTime is inclusive or exclusive of the input timestamp
  toDateTimeExclusive: Boolean = false

  # Match if the field value is `fromDateTime` or later
  fromDateTime: DateTime

  # Whether the fromDateTime is inclusive or exclusive of the input timestamp
  fromDateTimeExclusive: Boolean = false

  # Identify the field to filter on.
  field: TemporalDataObjectDateTimeField!
}

enum TemporalDataObjectOrderBy {
  createdDateTime
  modifiedDateTime
  startDateTime
  stopDateTime
}

# Time-only custom scalar type
scalar Time

# Information about a time zone
type TimeZone {
  # Time zone name, such as `America/Los_Angeles`
  name: String!

  # Known abbreviations for the time zone. These may include
  # offset variations such as those caused by daylight savings time.
  abbreviations: [TimeZoneAbbreviation!]!
}

# Information about a time zone abbreviation or variant.
type TimeZoneAbbreviation {
  # The abbreviation, such as "PST" or "UTC"
  name: String!

  # The offset from UTC in string form, such as `-08:00` for `PST`.
  offset: String

  # The offset from UTC in minutes, such as `-480` for `PST`.
  offsetMinutes: Int
}

type Token {
  # The token ID
  id: String
  applicationId: String
  groupId: String
  json: TokenJson
}

type TokenJson {
  rights: [String]
}

enum TokenType {
  API
  User
}

# The possible transformer functions which can be used with assets
enum TransformFunction {
  # Transform asset with XML format to JSON
  XML2JSON

  # Transfrom asset with XML Transcript format to JSON
  Transcript2JSON

  # Get asset JSON data as JSON
  JSON
}

# Contains information of a event hook
type Trigger {
  id: ID!
  event: String!
  target: String!
  consumerParams: JSON
  createdDateTime: DateTime!
  modifiedDateTime: DateTime!
  createdBy: String!
  updatedBy: String!
}

input UnfileTemporalDataObject {
  # ID of the TDO to unfile
  tdoId: ID!

  # ID of the parent folder. The TDO will be removed from this folder.
  folderId: ID!
}

input UnfileWatchlist {
  # ID of the watchlist to unfile
  watchlistId: ID!

  # ID of the parent folder. The watchlist will be removed from this folder.
  folderId: ID!
}

input UnpauseCluster {
  id: ID!
}

input UnpauseClusterNode {
  # Node ID
  id: ID!
}

type UnsubscribeEvent {
  # ID of the object that was deleted
  id: ID!

  # Message
  message: String
}

input UpdateApplication {
  id: ID!
  name: String
  status: ApplicationStatus
  category: String
  description: String
  iconUrl: String
  iconSvg: String
  url: String
  oauth2RedirectUrls: [String!]
  checkPermissions: Boolean
  permissionsRequired: [String!]
  deploymentModel: DeploymentModel
  contextMenuExtensions: UpdateContextMenuExtensions
}

input UpdateApplicationComponent {
  # the application id
  id: ID!

  # ids of the components to associate with application
  componentIds: [ID!]!
  type: ApplicationComponentType!
  action: UpdateApplicationComponentAction!
}

enum UpdateApplicationComponentAction {
  add
  remove
}

# Input needed to update an asset. The asset data itself -- file or URI --
# is immutable. Only supplemental metadata can be updated with this input type.
input UpdateAsset {
  # The asset ID. Required.
  id: ID!

  # The asset description.
  description: String

  # File name or other name for the asset
  name: String

  # Optionally, set attributes about the file
  fileData: SetAssetFileData

  # Optionally, set attributes about the source engine and task
  sourceData: SetAssetSourceData

  # Application- or type-specific metadata
  details: JSON
}

input UpdateBuild {
  id: ID!
  engineId: ID!
  action: BuildUpdateAction!
  dockerImage: String
}

input updateBundleStatusAsCluster {
  # Id of the cluster.
  clusterId: ID!

  # Id of the bundle.
  bundleId: ID!

  # Bundle status body object
  bundleStatus: BundleStatus!
}

input UpdateCluster {
  id: ID!
  name: String
  allowedEngines: [String]
  dockerCredentials: JSON
  containerTag: String
  memorySize: Int
  storageSize: Int
  bypassAllowedEngines: Boolean

  # Permissions granted to other organizations. Only the cluster owner
  # can view or edit this field.
  collaborators: [CreateClusterCollaborator!]

  # Tags for cluster
  tags: [String]
  status: ClusterStatus

  # Update the cluster config
  clusterConfig: JSON

  # Media storage path. Optional -- use only for edge.
  mediaStoragePath: String

  # Designate a management node ID. Used only for edge/portable clusters.
  # Must be the ID of an existing node in the cluster.
  managementNodeID: ID

  # Optionally, specify a time at which the edge cluster should
  # be restarted daily. Applies only to edge clusters.
  restartTimeUTC: Time

  # Update subscriptions on the cluster.
  subscriptions: [UpdateClusterSubscription]

  # Optionally, specify an api-token for cluster
  serviceToken: String
}

input UpdateClusterNode {
  id: ID!
  name: String

  # Update the cluster node config
  nodeConfig: JSON
  metrics: JSON
}

# Updates the state information for a given cluster
input UpdateClusterState {
  nodes: [ClusterNodeUpdate]

  # The cluster ID
  id: ID!
  state: JSON!

  # Optionally, update current the cluster status.
  targetStatus: ClusterStatus
}

input UpdateClusterSubscription {
  userId: ID!
  isActive: Boolean
}

input UpdateCognitiveSearch {
  id: ID!
  profile: JSON
  jsonstring: String
  mentionStatusId: ID
}

input UpdateCollection {
  # id of the collection
  folderId: ID!

  # the name of the collection
  name: String

  # description of the collection
  folderDescription: String

  # Collection image
  image: String
}

input UpdateCollectionMention {
  folderId: ID!
  mentionId: ID!
  description: String!
}

input UpdateContextMenuExtension {
  # The ID of the context menu extension to update
  id: ID!
  label: String!
  url: String
}

input UpdateContextMenuExtensions {
  mentions: [UpdateContextMenuExtension] = []
  tdos: [UpdateContextMenuExtension] = []
  watchlists: [UpdateContextMenuExtension] = []
  collections: [UpdateContextMenuExtension] = []
}

input UpdateCreative {
  id: ID!
  name: String
  keywords: String
  brandId: ID
  advertiserId: ID
}

input UpdateCurrentUser {
  # Required if updating the MFA phone number
  passwordToken: String

  # New MFA info for the current user, optional
  mfaInfo: UpdateMFAInfo

  # New user settings for the current user, optional
  userSetting: UserSettingInfo

  # New first name for the current user, optional
  firstName: String

  # New last name for the current user, optional
  lastName: String

  # New image URL for the current user, optional
  imageUrl: String
}

input UpdateDataRegistry {
  id: ID!
  name: String!
  description: String!
  source: String!
}

input UpdateDatasetConfidence {
  # Mininum Confidence Filter. Ignore sources having confidence lower than this
  min: Float

  # Maximum Confidence Filter. Ignore sources having confidence higher than this
  max: Float

  # allow sources with null confidence values
  allowNull: Boolean
}

# Input fields used to update an existing engine.
input UpdateEngine {
  # Supply the ID of the engine to update
  id: ID!

  # Indicates whether or not the engine should be public -- visible to and
  # usable by users outside the creator's organization.
  # Typically an engine should not be made public until it has been fully
  # configured and tested in production.
  isPublic: Boolean

  # Human-readable name for the engine. Changing this value will change
  # how the engine appears to users.
  name: String
  description: String
  categoryId: String

  # The engine deployment model. See the DeploymentModel enum for options.
  deploymentModel: DeploymentModel

  # An optional price indicator for the engine.
  price: Int

  # Optionally, supply custom fields that the user can set when launching
  # the engine. See developer documentation for details. To update the fields,
  # make sure you supply the complete set of new fields -- new fields,
  # updated existing fields, and unmodified existing fields.
  fields: [CreateEngineField!]

  # The path for an icon image
  iconPath: String

  # The path for a logo image
  logoPath: String

  # Whether or not the engine requires a library.
  libraryRequired: Boolean

  # List of use cases the engine serves
  useCases: [String!]

  # List of industries where the capabilities of the engine can be applied
  industries: [String!]

  # Generic Manifest for the engine based on data supplied during onboarding
  manifest: JSON
}

input UpdateEngineConfiguration {
  id: ID!
  credentialIds: [ID!]
}

input UpdateEngineDependency {
  # The category type this engine depends on.
  # Must be a valid categoryType from an existing EngineCategory.
  dependencyType: String

  # An optional asset type that the engine will expect to have
  # been created.
  assetType: String
}

input UpdateEntity {
  id: ID!
  name: String
  description: String
  profileImageUrl: String

  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSON

  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
}

input UpdateEntityIdentifier {
  id: ID!
  title: String
  isPriority: Boolean
  url: String

  # GraphQL-formatted JSON-like structure containing freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsonstring`, not both.
  jsondata: JSON

  # A string containing valid JSON with freeform metadata.
  # If a schema is associated with the entity type, the input will be
  # validated against the schema. Use this field _or_ `jsondata`, not both.
  jsonstring: String
}

input UpdateEntityIdentifierType {
  id: ID!
  label: String
  labelPlural: String
  iconClass: String
  description: String
  dataType: EntityIdentifierDataType
}

input UpdateEntityType {
  name: String
  namePlural: String
  schema: JSON
}

input UpdateEvent {
  # ID of event
  id: ID!

  # General description of the event
  description: String
}

input UpdateEventActionTemplate {
  # The id of the trigger template
  id: ID!

  # The name of template.  e.g. "Run engine X for every new mention in a watchlist".
  name: String

  # based on the input_type, input_validation describes additional validations. 
  # For example, if input_type is "event", input_validation could be a list of
  # allowed events.
  inputValidation: JSON

  # A JSON structure that is compatible/specific to the input_type.  For example,
  # if input type is "event", then input_attributes simply contain the entire event payload.
  inputAttributes: JSON

  # Allows you to specify validation for the action_type.  For example, if
  # action_type is "job", perhaps only whitelist a list of engines that could be called.
  actionValidation: JSON

  # dedicated column to specify where/what the action is taking place.  For
  # example, if action is a job, then destination is an engine_id.  For webhook, a uri.
  actionDestination: String

  # A JSON structure that is compatible with action_type.  For example, if
  # action_type is "webhook", action_attributes contain the mustache compatible
  # template to format the content.  If action_type is "job", then
  # action_attributes need to specify a job template.
  actionAttributes: JSON
}

type UpdateExecutionLocation {
  id: ID!
  clusterId: ID!
  nodeId: ID
}

input UpdateExportRequest {
  # ID of the export request to update
  id: ID!

  # Status change
  status: ExportRequestStatus

  # The asset URI
  assetUri: String
}

input UpdateExternalCredential {
  id: ID!
  dataId: ID
}

# Information required to update a folder.
# Currently, the folder can be renamed. No other changes are supported.
input UpdateFolder {
  # ID of the folder to update
  id: ID!

  # New name for the folder.
  name: String!
}

input UpdateFolderContentTempate {
  # The ID of Folder Content Template
  id: ID!

  # The ID of folder
  folderId: ID

  # The ID of Structure Data Object
  sdoId: ID

  # The ID of Data Registry
  schemaId: ID
  data: JSON
}

input UpdateJobPipeline {
  id: ID!
  jobTemplateIds: [ID!]
  isPublic: Boolean
}

input UpdateJobs {
  ids: [ID!]
  status: UpdateJobsStatus
}

enum UpdateJobsStatus {
  queued
}

input UpdateJobTemplate {
  id: ID!

  # taskTemplates: [CreateTaskTemplate!]
  jobPipelineStage: Int
  skipDecider: Boolean
  jobConfig: JSON
}

input UpdateLibrary {
  id: ID!
  name: String
  coverImageUrl: String
  description: String
  libraryTypeId: ID
  version: Int
}

input UpdateLibraryConfiguration {
  # library configuration id
  id: ID!

  # List of selected engines for training
  targetEngineIds: [ID]

  # This option is used for Dataset Library Only
  # List of selected engine where tdos are extracted from for training data
  # TDOs are extracted from higher ranked engines first then fallback to the lower
  # ones if the priors don't have any matching tdo
  rankedSourceEngineIds: [ID]

  # This option is used for Dataset Library Only
  # Dataset TDOs confidence filters
  confidence: UpdateDatasetConfidence
}

input UpdateLibraryEngineModel {
  # ID of the library engine model to update.
  id: ID!

  # Id of the train job.
  trainJobId: ID

  # Status of the train job.
  trainStatus: LibraryEngineModelTrainStatus

  # The URL to a file containing or related to the engine model.
  # Submit either this field _or_ `file`, not both.
  # Use this field if the data is stored in a separate, internet-accessible
  # location and not managed by Veritone APIs.
  dataUrl: String

  # Optional free-form block containing engine-specific metadata.
  jsondata: JSON

  # If a file is uploaded, you can explicitly specify the content type
  # (a valid MIME type string) with this field. Often this is not necessary
  # as the HTTP multipart form POST client will set content type on the
  # file object implicitly.
  contentType: String

  # An optional data file containing or related to the engine model.
  # Use multipart form POST to submit this field.
  # Submit either this field _or_ `dataUrl`, not both. If a file is
  # uploaded, the server will store it and then set `dataUrl` to
  # its location.
  file: UploadedFile
  accuracy: Int
  configurationId: ID
}

input UpdateLibraryType {
  id: ID!
  label: String!
  iconClass: String
  entityIdentifierTypeIds: [ID!]
  entityType: UpdateEntityType
}

input UpdateMention {
  id: ID!
  privateNote: String
  publicNote: String
  complianceStatusId: ID
  spotTypeId: ID
  statusId: ID
  adCreative: JSON
  userSnippets: JSON
}

input UpdateMentionComment {
  mentionId: ID!
  commentId: ID!
  commentText: String!
}

input UpdateMentionExportRequest {
  # The required mentionExportRequestId will be used for update
  id: ID!

  # Status of mentionExportRequest record
  status: ExportRequestStatus

  # The asset URI
  assetUri: String
}

input UpdateMentionRating {
  mentionId: ID!
  ratingId: ID!
  ratingValue: Int!
}

input UpdateMentions {
  ids: [ID!]!
  statusId: ID
}

input UpdateMFAInfo {
  phoneNumber: String
}

# Fields used to update an organization.
input UpdateOrganization {
  # ID of the organization to update
  id: ID!

  # Name of the organization
  name: String
  type: String
  seatLimit: Int
  status: String
  applications: [ID!]
  businessUnit: String

  # Currently only Veritone administrators can modify this field.
  metadata: JSON

  # Update the engine blacklist for this organization.
  # Currently only Veritone administrators can modify this field.
  # Updating this field will completely replacing the existing engine
  # and engine category blacklists with the IDs provided.
  blacklist: SetEngineBlacklist

  # Update the engine whitelist for this organization.
  # Currently only Veritone administrators can modify this field.
  # Updating this field will completely replacing the existing engine
  # and whitelist with the IDs provided.
  whitelist: SetEngineWhitelist
}

input UpdateProcessTemplate {
  id: ID!
  taskList: JSON!
}

input UpdateScheduledJob {
  id: ID!
  jobPipelineIds: [ID!]
  jobTemplateIds: [ID!]

  # Optionally, specify the job template definitions here.
  jobTemplates: [CreateJobTemplate!]
  weeklyScheduleParts: [CreateWeeklySchedulePart!]
  recurringScheduleParts: [CreateRecurringSchedulePart!]
  name: String

  # A detailed description. Defaults to name.
  description: String
  runMode: RunMode

  # JSON containing metadata details for this scheduled job.
  # If the scheduled job does not already have a schema ID
  # associated with, one must be supplied along with this data.
  # In either case, the supplied data must comply with the
  # schema.
  details: JSON

  # ID of the schema for detail metadata on this scheduled job
  detailsSchemaId: ID
  isActive: Boolean
  startDateTime: DateTime
  stopDateTime: DateTime

  # Optionally, associate content templates with the new scheduled job
  contentTemplates: [CreateScheduledJobContentTemplateWithScheduledJob!]

  # Indicates whether or not the scheduled job is publicly accessible.
  # Only Veritone administrators can create public scheduled jobs.
  # Other users will get an error if they attempt to set this value to true.
  isPublic: Boolean = false
  affiliates: [CreateProgramAffiliate!]

  # Indicates whether or not the scheduled job we should upgrade this schedule job
  # to the new data model if an upgrade is possible.
  migrateIfLegacy: Boolean = false
}

input UpdateSchemaState {
  # The schemaId to update
  id: ID!

  # The new schema status
  status: SchemaStatus!

  # Specify if publishing this schema would break ingestion
  breakingChanges: Boolean = false
}

input UpdateSharedCollectionHistory {
  # The ID of the shared collection history
  id: ID!

  # The new status of the shared collection
  status: SharedCollectionHistoryStatus!

  # Additional information regarding the status change
  statusNote: String

  # Number of times the shared collection has been retried
  retryCount: Int
}

# Data used to update an existing source
input UpdateSource {
  # The ID of the source to update
  id: ID!

  # Update the name field
  name: String

  # Update the isPublic field
  isPublic: Boolean

  # Additional metadata to associate with the source. This data may be
  # validated against a schema associated with the source type.
  details: JSON

  # Optional thumbnail image URL for the source
  thumbnailUrl: String

  # Optionally, associate content templates with the new source
  contentTemplates: [CreateSourceContentTemplateWithSource!]

  # Optionally associate a schema for correlation.
  # Required when correlationSDOId is specified.
  correlationSchemaId: ID

  # Optionally associate a structured data object of the specified correlationSchemaId.
  # Required when correlationSchemaId is specified.
  correlationSDOId: ID

  # Add or modify collaborators on the source. Permissions for organizations
  # not mentioned in this list will _not_ be modified. To revoke permissions
  # for an organization, use the `none` permission.
  collaborators: [CreateSourceCollaborator!]

  # Set current state for the source. This is used only by the adapters
  # that use the source and should not be set by other clients.
  state: JSON
}

input UpdateSourceType {
  id: ID!
  name: String
  sourceSchemaId: ID
  credentialSchemaId: ID
  details: JSON
  credentialType: CredentialType

  # Indicates that the source type is publicly accessible.
  # If false, is usable only by the owner organization.
  isPublic: Boolean

  # Indicates whether or not the source type is "live", such
  # as a camera feed
  isLive: Boolean

  # Indicates whether or not the source type requires
  # scan pipeline jobs
  requiresScanPipeline: Boolean = false

  # Source type category ID
  categoryId: ID
}

input UpdateSubscription {
  id: ID!
}

input UpdateTask {
  id: ID!
  status: TaskStatus!
  jobId: ID
  output: JSON

  # Task output as JSON string
  outputString: String

  #  Use this parameter if your task output does not take the form of valid
  #  JSON. Provide a key and the server will convert your output into
  #  JSON with a single string value. For example,
  #  ```
  #    mutation {
  #      updateTask(input: {
  #        id: <id>
  #        outputString: "<xml><stuff id=\"value\">more stuff </stuff></xml>"
  #        outputJsonKey: "response"
  #      }) { id }
  #    }
  #
  #  ```
  #  Will set the task output JSON to
  #   ` {"response":"<xml><stuff id=\"value\">more stuff </stuff></xml>"}`
  outputJsonKey: String

  # Backwards compatibility only
  taskOutput: JSON

  # Update the task with a new payload
  payload: JSON

  # Save execution location metadata
  executionLocationData: JSON

  # Optional timestamp used to control change ordering.
  # The client may set this to the `modifiedDateTime` value
  # of most recent copy of the task it has before making the
  # update. The server will _only_ update the task with the
  # requested changes _if_ and only if the current
  # `modifiedDateTime` value is equal to or earlier than
  # the supplied `clientTimestamp` value. Thus, changes
  # that were made after the client last retrieved the task
  # data will not be overwritten.
  clientTimestamp: DateTime

  # A code indicating why the task failed. Should be set
  # if and only if task status is `failed`.
  # If set with any other task status, the API will return an error.
  failureReason: TaskFailureReason

  # A human-readable string with detail on the
  # task failure reason. Should be set if and only if
  # task status is `failed` and `failureReason` is set.
  # If set with any other task status or if `failureReason` is not set,
  # the API will return an error.
  failureMessage: String
}

enum UpdateTaskStatus {
  running
  failed
  complete
  waiting
}

input UpdateTaskTemplate {
  id: ID!
  payload: JSON
  payloadString: String
  parentTaskId: ID
}

# Payload required to create a temporal data object
input UpdateTDO {
  # ID of the TDO to update
  id: ID!

  # Start date and time in numerical (epoch) format.
  startDateTime: DateTime

  # Stop date and time in numerical (epoch) format.
  stopDateTime: DateTime

  # Source for the TDO, such as an ingestion type or engine ID.
  source: String

  # Current status, such as "downloaded" or "recording".
  status: String

  # A name for the TDO object, such as the name of the primary media file.
  name: String

  # A description for the TDO object.
  description: String

  # Set the primary asset of a given type (transcript or media)
  primaryAsset: [SetPrimaryAsset!]

  # True if the new TDO should be made public. If true, security.global
  # will be set to true and users from other organizations will be able to
  # view, but not modify, the TDO's metadata and assets.
  isPublic: Boolean
  details: JSON

  # Optionally, specify one or more structured data objects to apply as
  # content templates to the TDO. They will be stored as assets of type
  # content-template and will contain an immutable copy of the original data.
  # Setting this field on an update does _not_ affect any content templates
  # previously added to the TDO -- it only creates the new ones.
  contentTemplates: [CreateTDOContentTemplateWithTDO!]

  # An optional thumbnail URL for the TDO
  thumbnailUrl: String

  # An optional preview asset URL for the TDO
  previewUrl: String

  # An optional image representing the TDO source
  sourceImageUrl: String
}

input UpdateUser {
  id: ID!
  name: String
  jsondata: JSON
  roleIds: [ID!]
  acls: [UserACLInput!]

  # Optionally, specify user's first name
  firstName: String

  # Optionally, specify user's last name
  lastName: String
}

input UpdateUserStatus {
  id: ID!
  status: UserStatus
}

input UpdateWatchlist {
  id: ID!
  startDateTime: DateTime
  stopDateTime: DateTime
  name: String
  sourceTypeIds: [ID!]

  # Set structured metadata on the watchlist.
  # The data is subject to a set of schemas.
  details: JSON
  searchIndex: SearchIndex
  parentFolderId: ID
  sourceIds: [ID!]
  subscriptions: [CreateSubscriptionInWatchlist!]
  cognitiveSearches: [CreateCognitiveSearchInWatchlist!]

  # Indicates whether or not the watchlist should be disabled.
  # The Veritone platform can administratively disable watchlists
  # if the search scope as measured in number of mentions
  # exceeds organization limits. The owner can then modify the
  # watchlist parameters to reduce the scope and re-enable the watchlist.
  isDisabled: Boolean
}

input UpdateWidget {
  id: ID!
  name: String
  adScript: String
  width: Int
  numberOfMentionsToShow: Int
  displayLogo: Boolean
  displayCollectionName: Boolean
  displayMentionIntro: Boolean
  displayTranscription: Boolean
  displayCollectionDescription: Boolean
  displayMentionDescription: Boolean
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  createdDateTime: DateTime
  nextButtonColor: String
}

# A custom scalar type representing a file upload in the asset input types
scalar UploadedFile

# Fields needed to upload and store an engine result using multipart form POST.
input UploadEngineResult {
  # ID of the task that created this engine result
  taskId: ID!

  # A string containing the engine result.
  # Use either this field, `output`, `uri`, or `file` with multipart form POST, but not
  # more than one.
  outputString: String

  # JSON data containing the engine result.
  # A string containing the engine result.
  # Use either this field, `outputString`, `uri`, or `file` with multipart form POST, but not
  # more than one.
  output: JSON

  # A file to upload. Use multipart form POST to submit this field.
  # Use this field, the `output`, `outputString`, or `uri` field, not more than one.
  file: UploadedFile

  # A URI to the file. Use one and only one of `uri`, `file`, or `output`/`outputString`.
  uri: String

  # The file name
  filename: String

  # The type of asset to create. Optional -- if not set, it will be
  # deduced from the engine category.
  # See https://docs.veritone.com/#/apis/tutorials/asset-types for supported values.
  assetType: String

  # The content type of the file. Optional -- if not set, it will
  # be deduced from the file name.
  contentType: String

  # Whether or not to mark the task as complete. Defaults to true.
  completeTask: Boolean = true

  # If the result data uploaded is not a valid JSON string, then
  # the task output data stored on the task object will be wrapped into
  # a JSON object using this key. The asset created, however, is not
  # modified in any way.
  outputJsonKey: String = "data"

  # Optionally, set attributes about the file
  fileData: SetAssetFileData

  # if true, sets the new asset to be the primary asset of its type.
  # Only certain asset types, such as "media" and "transcript",
  # can have primary assets.
  setAsPrimary: Boolean = false

  # Skips indexing the engine result, preventing mentions from being
  # generated over the results.
  skipIndexing: Boolean = false

  # Whether or not to set the legacy `task_output` data for compatible
  # with older clients.
  setTaskOutput: Boolean = true

  # Indicates that the result is one of a series of accumulated results
  # for a task and can replace existing data.
  # Used primarily by Veritone platform components.
  isAccumulatedResult: Boolean = false

  # An optional timestamp that the client can send in combination with
  # the `uri` and `isAccumulatedResult` parameters. If set, the uri
  # will only be updated if the currently saved asset metadata is older
  # than the timestamp value.
  clientTimestamp: DateTime
}

input UpsertSchemaDraft {
  dataRegistryId: ID!
  majorVersion: Int = 1
  schema: JSON!
}

# A user represents a user account within an organization.
type User {
  # The user's name
  name: String!

  # The user's unique ID.
  # A user ID is a string in UUID format.
  id: ID!

  # The set of permissions granted to the user
  permissions: PermissionList

  # The set of roles granted to the user
  roles: [Role!]
  roleIds: [ID!]

  # ID of the organization to which the user belongs.
  organizationId: ID

  # Organization to which the user belongs.
  organization: Organization

  # Freeform metadata in JSON form
  jsondata: JSON
  firstName: String
  lastName: String
  email: String
  acls: [UserACL!]

  # Folder tree for this organization
  rootFolder(
    # Specify a root folder type to retrieve a specific root folder
    type: RootFolderType = watchlist
  ): Folder

  # Date and time this user last changed their password
  passwordUpdatedDateTime: DateTime

  # Date and time this user last logged in
  lastLoginDateTime: DateTime

  # Date and time this user account was created
  createdDateTime: DateTime

  # Date and time this user account was last modified
  modifiedDateTime: DateTime

  # Multi-factor authentication information for the user
  mfaInfo: MFAInfo!

  # User Settings for the user
  userSettings: [UserSetting!]
  imageUrl: String

  # Status of user account
  status: UserStatus
}

type UserACL {
  applicationId: ID
  organizationId: ID
  organization: Organization
  objectType: String
  objectId: String
  access: UserACLAccessRights
  userId: ID
}

type UserACLAccessRights {
  owner: Boolean
}

input UserACLAccessRightsInput {
  owner: Boolean
}

input UserACLInput {
  applicationId: ID
  organizationId: ID
  objectType: String
  objectId: String
  access: UserACLAccessRightsInput
  userId: ID
}

type UserList implements Page {
  records: [User]

  # The starting index for records that were returned in this query.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

# Input fields required by the userLogin mutation.
input UserLogin {
  # The user login name -- typically, email address.
  userName: String!

  # The user password. Note that this value is only ever transmitted over
  # the encrypted SSL protocol.
  password: String!
}

enum UsersDateTimeField {
  lastLoginDateTime
  createdDateTime
}

input UsersDateTimeFilter {
  # Match if the field value is `toDateTime` or earlier
  toDateTime: DateTime

  # Whether the toDateTime is inclusive or exclusive of the input timestamp
  toDateTimeExclusive: Boolean = false

  # Match if the field value is `fromDateTime` or later
  fromDateTime: DateTime

  # Whether the fromDateTime is inclusive or exclusive of the input timestamp
  fromDateTimeExclusive: Boolean = false

  # Identify the field to filter on.
  field: UsersDateTimeField

  # Field to fallback on if the initial field is NULL in the DB
  fallbackField: UsersDateTimeField
}

# Type that holds user setting for a user
type UserSetting {
  key: String
  value: String
}

input UserSettingInfo {
  key: String
  value: String
}

enum UserStatus {
  active
  suspended
  deleted
}

type VerifyJWTPayload {
  # the same JWT input
  jwtToken: String!

  # the payload contained within the JWT
  payload: JSON!
}

type Watchlist {
  # The primary ID
  id: ID!

  # A human-readable name for the watchlist
  name: String!

  # The organization that owns the watchlist
  organization: Organization!

  # ID of the organization that owns the watchlist
  organizationId: ID!

  # IDs of the schedules associated with the watchlist
  scheduleIds: [ID!]

  # Date and time at which the watchlist takes effect
  startDateTime: DateTime

  # Date and time at which the watchlist is no longer in effect
  stopDateTime: DateTime

  # Date and time the watchlist was created
  createdDateTime: DateTime

  # Date and time the watchlist was last modified
  modifiedDateTime: DateTime

  # Cognitives searches associated with the watchlist
  cognitiveSearches: [CognitiveSearch!]

  # Ids of the source types associated directly with the watchlist
  sourceTypeIds: [ID!]

  # IDs of the sources associated directly with the watchlist
  sourceIds: [ID!]

  # Folders that the watchlist is filed in.
  # At present, a watchlist can only be filed in a single folder.
  folders: [Folder!]

  # Structured metadata associated with the watchlist.
  # Elements of the metadata are validated against specific schemas.
  details: JSON
  subscriptions: [Subscription!]!
  searchIndex: SearchIndex!
  query: JSON

  # Get mentions generated for this watchlist
  mentions(offset: Int = 0, limit: Int = 30): MentionList

  # ID of the advertiser directly with the watchlist
  advertiserId: ID

  # ID of the brand directly with the watchlist
  brandId: ID

  # advertiser associated with the watchlist
  advertiser: JSON

  # brand associated with the watchlist
  brand: JSON

  # creative associated with the watchlist
  creative: Creative

  # The reference to the watchlist in a folder
  treeObjectId: ID

  # Indicates whether or not the watchlist should be disabled.
  # The Veritone platform can administratively disable watchlists
  # if the search scope as measured in number of mentions
  # exceeds organization limits. The owner can then modify the
  # watchlist parameters to reduce the scope and re-enable the watchlist.
  isDisabled: Boolean

  # Contains the list of all source type IDs
  # associated with this watchlist, including
  # those for sources on schedules.
  combinedSourceTypeIds: [ID!]
  scheduledJobs(offset: Int = 0, limit: Int = 30): ScheduledJobList!

  # TODO for backward compat with v3 search?
  schedules(offset: Int = 0, limit: Int = 30): ScheduledJobList!
}

type WatchlistList implements Page {
  records: [Watchlist]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

enum WatchlistOrderBy {
  createdDateTime
  modifiedDateTime
  stopDateTime
  startDateTime
  name
}

type Widget {
  id: ID
  name: String
  organization: Organization
  organizationId: ID
  collection: Collection

  # A limited view of the collection metadata backing the widget
  collectionJSON: JSON
  collectionId: ID!
  displayCollectionName: Boolean
  displayCollectionDescription: Boolean
  displayTranscription: Boolean
  displayMentionDescription: Boolean
  displayMentionIntro: Boolean
  displayLogo: Boolean
  width: Int
  numberOfMentionsToShow: Int
  adScript: String
  seoTags: [String]
  backgroundColor: String
  borderColor: String
  textColor: String
  nextButtonColor: String
  createdDateTime: DateTime
  mentions(
    # Provide an offset to skip to a certain element in the result, for paging.
    offset: Int = 0

    # Specify maximum number of results to retrieve in this result. Page size.
    limit: Int = 30
  ): SharedMentionList
}

type WidgetList implements Page {
  records: [Widget]

  # Provide an offset to skip to a certain element in the result, for paging.
  offset: Int!

  # Maximum number of results that were retrieved in this query; page size
  limit: Int!

  # Number of records returned in this response
  count: Int
}

type WorkflowMetric {
  # The number of users who have access to Flow
  flowSeatCount: Int!

  # The flow engine task count
  flowTaskCount: Int!
}

type WorkflowRuntimeResponse {
  success: Boolean!

  # Error message if success is false
  message: String

  # uri of veritone workflow instance.
  # This is only available when Workflow request is successful
  uri: String

  # Authentication token used for webhooks
  authToken: String

  # Creation date of this history record
  createdDateTime: DateTime

  # Last modified date of this history record
  modifiedDateTime: DateTime
}

type WorkflowRuntimeStorageData {
  # Unique lookup id for the workflowRuntimeData
  storageKey: String!

  # Data content - base64 encoded binary, plain string or encoded JSON
  storageData: String!

  # Optional metadata for the workflowRuntimeData
  storageMetadata: String
}

type WorkflowRuntimeStorageDataList implements Page {
  records: [WorkflowRuntimeStorageData]
  count: Int
  offset: Int!
  limit: Int!
}

# Contains information about a signed writable URL retrieved from the
# getSignedWritableUrl mutation.
type WritableUrlInfo {
  # The storage bucket ID
  bucket: String!

  # The storage object key
  key: String!

  # Time interval, in seconds, after which this URL is expired and no longer valid.
  expiresInSeconds: Int!

  # Absolute time at which this URL expires
  expiresAtDateTime: DateTime!

  # The signed URL, which can be uploaded to with an HTTP PUT (note:  PUT is
  # required. POST will generate an error).
  url: String!

  # A signed URL that can be used with HTTP GET to retrieve the
  # new resource.
  getUrl: String!

  # The unsigned, base URL to the object, which can be safely persisted
  # and re-signed later by a client with the necessary storage credentials.
  unsignedUrl: String
}

